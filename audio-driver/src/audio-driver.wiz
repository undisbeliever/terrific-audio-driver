// Audio Driver
//
// SPDX-FileCopyrightText: © 2023 Marcus Rowe <undisbeliever@gmail.com>
// SPDX-License-Identifier: Zlib
//
// Copyright © 2023 Marcus Rowe <undisbeliever@gmail.com>
//
// This software is provided 'as-is', without any express or implied warranty.  In
// no event will the authors be held liable for any damages arising from the use of
// this software.
//
// Permission is granted to anyone to use this software for any purpose, including
// commercial applications, and to alter it and redistribute it freely, subject to
// the following restrictions:
//
//      1. The origin of this software must not be misrepresented; you must not
//         claim that you wrote the original software. If you use this software in
//         a product, an acknowledgment in the product documentation would be
//         appreciated but is not required.
//
//      2. Altered source versions must be plainly marked as such, and must not be
//         misrepresented as being the original software.
//
//      3. This notice may not be removed or altered from any source distribution.


import "registers";
import "data-formats";
import "io-commands";
import "common_memmap";

config {
    trim = true
}

bank code           @ CODE_ADDR             : [constdata; CODE_SIZE];
bank lastvarpage    @ CODE_ADDR + CODE_SIZE : [vardata; LAST_VAR_PAGE_SIZE];


extern const commonDataHeader @ COMMON_DATA_ADDR : CommonDataHeader;
let COMMON_DATA_HEADER_END_ADDR = COMMON_DATA_ADDR + sizeof(CommonDataHeader);


// Must wait a minimum of 240ms after setting `EDL` and `ESA` before reading/writing the echo buffer.
//
// Added a little extra to be safe.
let EDL_SLEEP_MS = 250;

// Instead of setting TIMER_1 register to 8 and counting `EDL_SLEEP_MS` clocks, we can set TIMER_1 to `EDL_SLEEP_MS` and wait 8 clocks.
let EDL_SLEEP_TIMER_1 = EDL_SLEEP_MS;
let EDL_SLEEP_COUNT   = smp.TIMER_1_HZ / 1000;

// Assert EDL_SLEEP_COUNT < 12


let I8_MIN = -128_i8;
let I8_MAX = 127_i8;


// Variables
// =========

let FIRST_MUSIC_CHANNEL = 0;
let LAST_MUSIC_CHANNEL = N_MUSIC_CHANNELS - 1;
let FIRST_SFX_CHANNEL = LAST_MUSIC_CHANNEL + 1;
let LAST_SFX_CHANNEL = N_CHANNELS - 1;


// Using separate values for slide and triangle to simplify the rust bytecode interpreter.
// See: `channelSoA.volEffect_direction`
let VOL_PAN_EFFECT_SLIDE_UP      = 0x80;
let VOL_PAN_EFFECT_SLIDE_DOWN    = 0x81;
let VOL_PAN_EFFECT_TRIANGLE_UP   = 0x40;
let VOL_PAN_EFFECT_TRIANGLE_DOWN = 0x41;


in zeropage {
    // Temporary variables
    var zpTmpWord : u16;
        var zpTmp  @ &<:zpTmpWord as u8 : u8;
        var zpTmp2 @ &>:zpTmpWord as u8 : u8;


    // Increases once every song tick
    var songTickCounter : u16;


    // Enabled or disabled music channels.
    // A bitmask of the music channels that can send key-on events.
    //
    // This bitmask is set by the SET_MUSIC_CHANNELS IO comamnd, it is not `keyOnMask`.
    var io_musicChannelsMask : u8;


    // The table of subroutine offsets
    var subroutineTable_l : *const u8;
    var subroutineTable_h : *const u8;

    // Maximum value of the timer counter_0 or counter_1 register.
    var maxTimerCounter : u8;


    // bitmask - Set if S-DSP voice channel is music, clear if sfx.
    // Used to disable music channel S-DSP writes that are used by sound effects.
    // Bits 0-5 MUST be set.
    // MUST ONLY be modified by `_process_sfx_channels__inline()`.
    var musicSfxChannelMask : u8;

    // bitmask - Set if S-DSP voice channel is sfx, clear if music
    //           (opposite to `musicSfxChannelMask`).
    // Used to enabled/disable noise and echo when sound effects channels are active.
    // MUST ONLY be modified by `_process_sfx_channels__inline()`.
    var sfxMusicEchoNoiseMask : u8;

    // bitmask - Set if S-DSP voice channel is sfx.
    // Used to disable S-DSP voice register writes for unused sfx channels.
    // Used to determine the next available sound effect channel.
    var activeSoundEffects : u8;

    // The `activeSoundEffects` value in the previous sfx tick.
    var prevActiveSoundEffects : u8;

    // bitmask - Set if the sound effect is interruptible
    // (only uses bits 6 & 7)
    var sfx_interruptibleFlags : u8;


    // The remaining duration of the two sound effects in ticks
    var sfx_remainingTicks : [u16 ; N_SFX_CHANNELS];

    // Used to detect active one-channel sound effects.
    // This value MUST BE 0xff if the channel is disabled or the *one-channel* flag is clear.
    var sfx_oneChannelSfxId : [u8 ; N_SFX_CHANNELS];


    // S-DSP voice channels dirty flags.
    // Used to test if the virtualChannels should be written to the S-DSP voice registers.
    // (using a bitset so they can be masked when channel ducking)
    var voiceChannelsDirty_music : u8;
    var voiceChannelsDirty_sfx   : u8;


    // Shadow variables for KOFF DSP register
    var keyOffShadow_music : u8;
    var keyOffShadow_sfx : u8;

    // Shadow variables for KON DSP register
    var keyOnShadow_music : u8;
    var keyOnShadow_sfx : u8;

    // Shadow variable for the PMON S-DSP register
    var pmonShadow : u8;

    // Shadow variable for the EON S-DSP register
    var eonShadow_music : u8;
    var eonShadow_sfx : u8;


    // `keyOnShadow` mask.
    //
    // Each bit determines the channel bytecode should emit a key-on event.
    //  * If set - the next play note instruction will set `keyOnShadow`.
    //  * If clear - the channel is playing something and the play note instruction will
    //               leave `keyOnShadow` unchanged (slurring the note).
    // (8x bit array)
    var keyOnMask_music : u8;
    var keyOnMask_sfx : u8;


    // Only valid inside bytecode instructions
    var instructionPtr : *const u8;


    // Temporary variable for reading and writing `voiceChannelsDirty_*` bits.
    var voiceChannelsDirty_tmp  : u8;


    // Temporary variable holding `globalVolume_music` or `globalVolume_sfx`
    var globalVolume_tmp : u8;


    namespace channelSoA {
        // Counter (in ticks) until the event
        var countdownTimer : [u8 ; N_CHANNELS];

        // If non-zero, the next event is a key-off event
        // If zero, the next event will process bytecode
        var nextEventIsKeyOff : [u8 ; N_CHANNELS];


        // S-DSP voice register shadows (AKA Virtual Channels)
        namespace virtualChannels {
            var vol_l       : [u8 ; N_CHANNELS];
            var vol_r       : [u8 ; N_CHANNELS];
            var pitch_l     : [u8 ; N_CHANNELS];
            var pitch_h     : [u8 ; N_CHANNELS];
            var scrn        : [u8 ; N_CHANNELS];
            var adsr1       : [u8 ; N_CHANNELS];
            // If the MSB of adsr1 is set, this value is written to the ADSR2 register.
            // If the MSB of adsr1 is clear, this value is written to the GAIN register.
            var adsr2OrGain : [u8 ; N_CHANNELS];

            // Temporary GAIN
            //
            // If this variable is non-zero, it overrides `adsr1` and `adsr2OrGain`.
            // Reset to 0 on key-off.
            var tempGain : [u8 ; N_CHANNELS];
        }


        // The address of the next bytecode to execute.
        //
        // If the high-byte of the instructionPtr is 0, no bytecode will be executed.
        //
        // (The low-byte of instructionPtr is in lastvarpage)
        var instructionPtr_h : [u8 ; N_CHANNELS];


        // The stack pointer to use in the `skip_last_loop_*` and `end_loop` instructions.
        //
        // Used to skip bounds checking when reading/modifying counter.
        //
        // CAUTION: Not equal to `stackPointer` if there is less than 2 or fewer bytes on the stack.
        //
        // MUST always be >= `BcStackIndexesEnd[x]` and <= `(BcStackIndexesStart[x] - 3)`
        //
        // (index into `bcStack`)
        var loopStackPointer : [u8 ; N_CHANNELS];


        // Portamento direction
        //  * zero - portamento disabled
        //  *  > 0 - increase pitch
        //  *  < 0 - decrease pitch
        var portamento_direction : [i8 ; N_CHANNELS];



        // Vibrato PITCH offset per tick.
        //
        // If this value is 0, vibrato is disabled.
        //
        // (pitch change/tick)
        var vibrato_pitchOffsetPerTick : [u8 ; N_CHANNELS];

        // Vibrato direction.
        // The lsb controls the vibrato direction.
        var vibrato_direction : [u8 ; N_CHANNELS];
    }


    // Used to determine if vol_l and vol_r need recalculating.
    // In the `__process_channels()` loop, bit 7 is left-shifted out and the volume is updated if set.
    // (bit array)
    var volShadowDirty_tmp : u8;

    // Used to determine if all music channels should be updated.
    // Set in the SET_GLOBAL_MUSIC_VOLUME IO command.
    //
    // Must only contain 0x00 or 0xff.
    //
    // CAUTION: These bits are in reverse order, compared to other *_music bit-arrays.
    var volShadowDirty_music : u8;

    // The sound effects with invalid vol_l and vol_r shadow variables.
    // Set in the PLAY_SOUND_EFFECT and SET_GLOBAL_SFX_VOLUME IO commands.
    // CAUTION: bits 6 & 7 are swapped from other the other *_sfx bitsets
    // (bit array)
    var volShadowDirty_sfx : u8;


    // Controls which channel has ownership if the noise frequency
    //
    // VALUES:
    //   * 0    = music channels
    //   * 0x80 = sfx channel 9
    //   * 0x40 = sfx channel 8
    //
    // This variable MUST not have bits 6 & 7 set at the same time
    //
    // To simplify timing, this variable is set at the start of `_process_sfx_channels__inline()`.
    var noiseLock : u8;

    // The last SFX voice-bit that encountered a `play_noise` instruction.
    //
    // VALUES:
    //   * 0x80 = sfx channel 9
    //   * 0x40 = sfx channel 8
    //
    // This variable MUST not have bits 6 & 7 set at the same time
    var lastSfxPlayNoiseChannel : u8;

    // noise frequency register shadow variables
    //
    // These variables MUST ALWAYS be `<= dsp.FLG__NOISE_FREQ_MASK`.
    var noiseFreq_music : u8;
    var noiseFreq_sfx : [u8; N_SFX_CHANNELS];


    // NON DSP register shadow variables.
    //
    // Must only be edited by `_process_*_channels()`.
    // Edit `pendingNon_*` instead.
    var nonShadow_music : u8;
    var nonShadow_sfx : u8;


// --- All zeropage variables after this point are not cleared in main() ---
let __EndZeropageClearAddr = &maxEdl as u8;

    // The maximum echo delay in the song.
    // Used to determine the size and location of the echo buffer in Audio-RAM.
    var maxEdl : u8;


    // Used to determine if the S-DSP echo registers need updating.
    //
    // (bit field)
    //
    // CAUTION: Also used to temporally store SongHeader.activeMusicChannels in the start of main()
    var echoDirty : u8;
        let ECHO_DIRTY__FIR_FILTER_BIT = 7;
        let ECHO_DIRTY__CLEAR_FIR_BIT = 0;  // Clear FIR filter before writing FIR filter
        let ECHO_DIRTY__VOLUME_BIT = 6;

        // Not tested in `_process_echo_registers__inline()`
        // Instead they will be written whenever echoDirty is non-zero
        let ECHO_DIRTY__FEEDBACK_BIT = 5;
        let ECHO_DIRTY__EDL_BIT = 4;


    // Echo buffer settings
    //
    // MUST be last, used to determine when zeropage is cleared.
    var echo : EchoBufferSettings;


    // Common audio data pointers.
    // See `data-formats.wiz` for more details about these variables.
    //
    // Also used to temporally store SongHeader fields after `SongHeader.echo` in the start of `main()`
    var commonData : CommonDataPointers;
}


in firstpage {
    // Pending NON shadow variable changes.
    //
    // This value will be written to `nonShadow_*` at the start of the next tick.
    //
    // Delaying `pendingNon_*` NON writes fixes a bug where NON is set in the middle of the release envelope.
    var pendingNon_music : u8;
    var pendingNon_sfx : u8;

    // Cached SFX mutedChannels parameter for `__process_channels()`.
    var sfxMutedChannels : u8;


    // Channel variables that do not fit in zeropage
    namespace channelSoA {
        // Delay before vibrato is applied to the current note (using `ticksAfterNote`).
        // (ticks)
        var vibrato_delay : [u8 ; N_CHANNELS];

        // Countdown for vibrato direction change
        // (ticks)
        var vibrato_tickCounter : [u8 ; N_CHANNELS];

        // The vibrato tickCounter to reset to when changing direction (`quarterWavelengthInTicks*2`).
        var vibrato_halfWavelength : [u8 ; N_CHANNELS];

        // The value to reset `vibrato_tickCounter` counter to when playing a note or starting a vibrato.
        //
        // This variable is equal to the `quarterWavelengthInTicks` parameter of the `set_vibrato` instruction
        //
        // Offsetting the start of the vibrato saves a comparison in `_process_vibrato__inline()`.
        var vibrato_tickCounterStart : [u8 ; N_CHANNELS];


        // i16 VxPITCH offset added to every play_note or portamento instruction
        var detune_l : [u8 ; N_CHANNELS];
        var detune_h : [u8 ; N_CHANNELS];


        // Channel invert flags:
        //      rl0000m0
        //      r = invert right channel
        //      l = invert left channel
        //      m = invert both channels in mono mode
        var invertFlags : [u8 ; N_CHANNELS];


        // Channel volume (0-255)
        var volume : [u8 ; N_CHANNELS];

        // Fractional volume (used for volume effects)
        var subVolume : [u8 ; N_CHANNELS];

        // Volume effect direction.
        //  * zero - volume effect disabled
        //  * bit 0 clear - increment volume
        //  * bit 0 set - decrement volume
        var volEffect_direction : [u8 ; N_CHANNELS];

        // Countdown ticks for volume effects
        // (ticks)
        var volEffect_counter : [u8 ; N_CHANNELS];

        // Volume offset per tick
        // (8.8 unsigned fixed point)
        var volEffect_offset_l : [u8 ; N_CHANNELS];
        var volEffect_offset_h : [u8 ; N_CHANNELS];

        // Tremolo half-wavelength in ticks.
        // If 0, the volume effect is a volume slide.
        var volEffect_halfWavelength : [u8 ; N_CHANNELS];


        // Channel pan (0-MAX_PAN)
        var pan : [u8 ; N_CHANNELS];

        // See volEffect variables
        var subPan : [u8 ; N_CHANNELS];
        var panEffect_direction : [u8 ; N_CHANNELS];
        var panEffect_counter : [u8 ; N_CHANNELS];
        var panEffect_offset_l : [u8 ; N_CHANNELS];
        var panEffect_offset_h : [u8 ; N_CHANNELS];
        var panEffect_halfWavelength : [u8 ; N_CHANNELS];

        // Early release comparison argument
        // (the other 2 arguments are in lastvarpage)
        var earlyRelease_cmp : [u8 ; N_CHANNELS];
    }


    // The previous IO port command
    var previousCommand : u8;
}


in lastvarpage {
    namespace channelSoA {
        // Offset between the note to play and the pitch table.
        //
        // NOTE: Adding `instPitchOffset` to the note to play is allowed to an can overflow.
        var instPitchOffset : [u8 ; N_CHANNELS];

        // Semitone offset for all play-note and portamento-note instructions.
        var transpose : [u8 ; N_CHANNELS];


        // set_early_release instruction arguments
        var earlyRelease_minTicks : [u8 ; N_CHANNELS];
        var earlyRelease_gain : [u8 ; N_CHANNELS];


        // The address of the next bytecode to execute
        // (The high-byte of instructionPtr is in zeropage)
        var instructionPtr_l : [u8 ; N_CHANNELS];


        // Portamento PITCH speed
        // (pitch change/tick)
        var portamento_speed : [u8 ; N_CHANNELS];

        // Portamento target pitch
        var portamento_target_l : [u8 ; N_CHANNELS];
        var portamento_target_h : [u8 ; N_CHANNELS];


        // Stack pointer.
        // The stack grows downwards,
        // from highest address (BcStackIndexesStart[x]) to lowest address (BcStackIndexesEnd[x])
        //
        // CAUTION: Is out of bounds when the stack is empty.
        // CAUTION: `bcStack` label is offset by BC_CHANNEL_STACK_OFFSET.
        //
        // MUST always be >= `BcStackIndexesEnd[x]` and <= `(BcStackIndexesStart[x]`
        //
        // (index into `bcStack`)
        var stackPointer : [u8 ; N_CHANNELS];


        // The previous temp-GAIN used by the channel.
        var prevTempGain : [u8 ; N_CHANNELS];

        // Number of ticks since the last play_note or portamento instruction.
        // ::MAYDO move to zeropage::
        var ticksAfterNote : [u8 ; N_CHANNELS];
    }

    // The bytecode stack
    //
    // CAUTION: `bcStack` is offset by BC_CHANNEL_STACK_OFFSET to eliminate signed comparisons.
    var __bcStack : [u8 ; BC_CHANNEL_STACK_SIZE * N_CHANNELS];
        var bcStack @ (&__bcStack as u16) - BC_CHANNEL_STACK_OFFSET : [u8 ; BC_CHANNEL_STACK_SIZE * N_CHANNELS + BC_CHANNEL_STACK_OFFSET];
}


// Macros
// ======

// KEEP: a, x, y
inline func write_dsp(addr : GlobalDspAddr in a, data : u8 in y) {
    smp.dsp_addr_and_data = ya;
}


// ::BUGFIG This inline func fixes a "left-hand side of type `u16` cannot be assigned `u8` expression" error when multiplying a and y::
inline func mul(u8a : u8 in a, u8b : u8 in y) : u16 in ya {
    return a * y;
}



// Code
// ====

in code {

// MUST be the first thing in the `code` bank (so the starting address is consistent across builds).
#[fallthrough]
func main() {
    sp = x = 0xff;
    direct_page = false;

    // Tell the S-CPU the S-SMP is running the audio driver
    IO.ToScpu.mode = IO.ToScpu.MODE_AUDIO_DRIVER;

    // Reset the DSP
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__SOFT_RESET | dsp.FLG__MUTE_ALL | dsp.FLG__ECHO_DISABLE);

    write_dsp(GlobalDspAddr.KOFF,   0xff);  // all keys off


    // Assumes offsetof(SongHeader, echo) == 1
    // Assumes __EndZeropageClearAddr <= _songHeader
    var _songHeader @ &echo as u8 - offsetof(SongHeader, echo) : SongHeader;

    // Assumes `offset(SongHeader, activeMusicChannels) == 0`
    y = 0;
    _songHeader.activeMusicChannels = a = songPtr[y];

    // Copy SongHeader data to zeropage
    // If activeSoundEffects is 0, clear SongHeader in zeropage
    y = offsetof(SongHeader, echo);
    do {
        a = _songHeader.activeMusicChannels;
        if !zero {
            a = songPtr[y];
        }
        (&_songHeader as *u8)[y] = a;
        y++;
    } while y < sizeof(SongHeader);


    // Setup echo.
    //
    // This is done as soon as possible as we need to wait a while after setting EDL and ESA.
    {
        // Assumes ECHO write is disabled.

        // Extract maximum EDL from EchoBufferSettings
        // and calculate echo start address
        a = echo.edl;
        swap_digits(a);
        a &= 0xf;
        maxEdl = a;

        // a = 0x100 - a * (2048 / 256)
        //
        // Multiply by 8
        // (XCN is safe, A has been masked)
        swap_digits(a);
        a >>>= 1;

        // Negate A
        a ^= 0xff;
        a++;

        if zero {
            // Ensure echo buffer is at the end of audio-ram when EDL is 0.
            // When EDL is 0, the echo buffer is 4 bytes in size.
            a--;
        }

        // set ESA (Echo start address??)
        smp.dsp_addr = GlobalDspAddr.ESA as u8;
        smp.dsp_data = a;

        // Save S-DSP ESA for later.
        push(a);


        // Mask and clamp EDL
        a = echo.edl & 0xf;
        if a >= maxEdl {
            a = maxEdl;
        }
        echo.edl = a;

        // Set EDL
        // Assumes GlobalDspAddr.EDL = GlobalDspAddr.ESA | 0x10
        smp.dsp_addr $ 4 = true;
        smp.dsp_data = a;


        // `EDL` does not take affect immediately.
        // The S-DSP reads `EDL` when the echo buffer is full and wraps around.
        //
        // Since `EDL` starts in an uninitialised state, we must wait a minimum of 240ms before
        // setting echo volume or enabling echo writes.
        //
        // Setup a timer here and enable echo writes at the end of driver initialization.
        //
        // Source: fullsnes https://problemkaputt.de/fullsnes.htm#snesapudspechoregisters

        // Using timer1 as timer0 is setup before echo buffer clear.
        smp.timer_1 = EDL_SLEEP_TIMER_1;

        // Reset and enable timer 0 (timers are reset on a transition from 0 to 1)
        smp.control = 0;
        smp.control = smp.CONTROL__ENABLE_TIMER_1;
    }

    // A copy of S-DSP `ESA` is on the stack.


    y = 0;
    write_dsp(GlobalDspAddr.EON,    y);     // No echo


    // Set main volume to full volume
    y = 0x7f;
    write_dsp(GlobalDspAddr.MVOL_L, y);
    write_dsp(GlobalDspAddr.MVOL_R, y);

    // Set directory table
    write_dsp(GlobalDspAddr.DIR, >:COMMON_DATA_HEADER_END_ADDR);


    // Clear all zero-page variables before `__EndZeropageClearAddr` variables
    // Assumes `songPtr` and `loaderDataType` is AFTER `zeropage` bank.
    a = 0;
    x = __EndZeropageClearAddr;
    do {
        x--;
        *(x as *u8) = a;
    } while !zero;

    pendingNon_sfx = a;
    pendingNon_music = a;
    sfxMutedChannels = a;


    carry = loaderDataType $ LoaderDataType.RESET_GLOBAL_VOLUMES_BIT;
    if carry {
        // a = 0
        globalVolume_music = a;
        globalVolume_sfx = a;
    }


    // Assumes N_MUSIC_CHANNELS == 8
    x = N_MUSIC_CHANNELS - 1;
    y = sizeof(SongHeader);
    do {
        _songHeader.activeMusicChannels <<<= 1;
        if carry {
            // Calculate instructionPtr (disabling the channel if the addition overflows)
            channelSoA.instructionPtr_l[x] = a = songPtr[y] + <:songPtr;
            y++;

            a = songPtr[y] +# >:songPtr;
            y++;

            if carry {
                // Disable channel
                a = 0;
            }
            channelSoA.instructionPtr_h[x] = a;
        }

        push(y);

        __reset_channel(x, MAX_PAN / 2);

        y = pop();

        x--;
    } while !negative;

    // Y = offset after songChannel addresses


    // Calculate `subroutineTable` addresses.
    // subroutineTable_l = songPtr + y
    a = y;
    y = 0;
    ya += songPtr as u16;
    subroutineTable_l = ya as *const u8;

    // subroutineTable_h = subroutineTable_l + nSubroutines
    a = _songHeader.nSubroutines;
    y = 0;
    ya += subroutineTable_l as u16;
    subroutineTable_h = ya as *const u8;


    smp.timer_0 = _songHeader.tickTimer;


    // No need to reset SFX channels.
    // The sfx channels are disabled as `instructionPtr_h` is 0.


    // Copy Common Audio Data pointers to zeropage
    {
        x = sizeof(typeof(commonData)) - 1;
        do {
            (&commonData as *u8)[x] = a = (&commonDataHeader.pointers as *u8)[x];
            x--;
        } while !negative;
    }


    // If not in surround mode, set all echo.invertFlags to the mono-flag
    // (cannot use `bbs` instructions in wiz, using `mov1 c, addr, bit` instead)
    carry = loaderDataType $ LoaderDataType.SURROUND_FLAG_BIT;
    if !carry {
        a = echo.invertFlags & INVERT_FLAGS.MONO;
        if !zero {
            a = 0xff;
        }
        echo.invertFlags = a;
    }


    // Reset bit-masks
    a = 0xff;
    echoDirty = a;
    io_musicChannelsMask = a;
    musicSfxChannelMask = a;
    volShadowDirty_music = a;
    keyOnMask_music = a;

    inline for let _I in 0..(N_SFX_CHANNELS - 1) {
        sfx_oneChannelSfxId[_I] = a;
    }


    // Pop ESA from the stack
    x = pop();


    // Clear the echo buffer and wait until the echo buffer can be safely written to.
    //
    // In the GUI, spc-export and unit-tests this block of code is patched out
    // and replaced with a `JMP ClearEchoBufferEnd ; NOP ...`.
ClearEchoBufferStart:
    {
        // ::TODO remove (required to compile compiler crate)::
        nop();

        // Clear the echo buffer
        // X = S-DSP ESA
        __clear_echo_buffer__inline(x);


        // Wait until the echo buffer can be safely written to.
        // (wait until `EDL_SLEEP_COUNT` ticks of TIMER_1)
        a = EDL_SLEEP_COUNT - 1;
        do {
            a -= smp.counter_1;
        } while carry;
    }
ClearEchoBufferEnd:

    // SFX timer
    smp.timer_1 = SFX_TICK_CLOCK;

    // Timers are enabled and reset in `io_commands.unpause()`


    // Enable echo write and unmute the DSP
    write_dsp(GlobalDspAddr.FLG, 0);


    io_commands.init__inline();


// Fallthrough into mainloop()
}


func mainloop() {
    // Reset counters to ensure `maxTimerCounter` is accurate
    // Timers and counters reset when the timer control bits transition from 0 to 1
    smp.control = 0;

    // (cannot use `bbs` instructions in wiz, using `mov1 c, addr, bit` instead)
    carry = loaderDataType $ LoaderDataType.PLAY_SONG_BIT;
    if carry {
        smp.control = smp.CONTROL__ENABLE_TIMER_0 | smp.CONTROL__ENABLE_TIMER_1;
    }

    // Clear smp.copunter_0 and smp.counter_1.
    // Fixes a single audible song tick/note when LoaderDataType.PLAY_SONG_BIT is clear
    // and the console has just powered-on.
    // (The bug does not occur when the console is reset or when a new song is loaded).
    ya = *(&smp.counter_0 as *u16);

    // Process first song tick immediately
    // So echo registers are setup before the first sfx tick
    goto ProcessMusicChannel;

    Loop:
        io_commands.process_io_ports__inline();

        // Song tick timer
        a = smp.counter_0;
        goto SkipMusicTick if zero;
            if a >= maxTimerCounter {
                maxTimerCounter = a;
            }

        ProcessMusicChannel:
            process_music_channels();
    SkipMusicTick:

        // SFX tick timer
        a = smp.counter_1;
        goto Loop if zero;

            if a >= maxTimerCounter {
                maxTimerCounter = a;
            }

            _process_sfx_channels__inline();

            // Loop forever
            ^goto Loop;
}



// Clears the echo buffer.
//
// ASSUMES: IPL is disabled
// ASSUMES: X matches the `ESA` S-DSP register
//
// WARNING: Can clobber the entirely of Audio-RAM if `esa` is invalid.
//
// WARNING: self modifying code
inline func __clear_echo_buffer__inline(esa : u8 in x) {
    // X = page address of the start of the echo buffer
    // Echo buffer ends at the end of memory.

    // Set the high byte of the `mov !abs+Y, a` instructions.
    (&STA_1 as *u8)[2] = x;
    (&STA_2 as *u8)[2] = x;

    a = 0;

    // Have to use a manual loop so the above code can access the `MOV_absY_A` label.
    OuterLoop:
        y = 0x80;
        InnerLoop:
            // Write 2 bytes every loop.
            // Writing 1 byte per loop is too slow (COUNTER_0 is 11 when it should be <=8 (TIMER_0=250)).
        STA_1:
            (0x0000 as *u8)[y] = a;
        STA_2:
            (0x0080 as *u8)[y] = a;

            goto InnerLoop if --y != 0;

        // Advance to the next page
        (&STA_1 as *u8)[2]++;
        (&STA_2 as *u8)[2]++;
        goto OuterLoop if !zero;
}


// Process music channels.
//
// Not inline for 2 reasons:
//   1. Used by the GUI to determine if the audio driver is processing music channels.
//   2. Will be required when I add loading ditties to the audio driver.
func process_music_channels() {
    songTickCounter++;

    nonShadow_music = a = pendingNon_music;

    // Clears NON on the tick after key-off
    a = keyOffShadow_music;
    test_and_clear(a, pendingNon_music);

    y = a = a & musicSfxChannelMask;
    write_dsp(GlobalDspAddr.KOFF, y);

    _process_echo_registers__inline();


    volShadowDirty_tmp = volShadowDirty_music;

    y = 0;
    keyOffShadow_music = y;
    volShadowDirty_music = y;

    // Set mutedChannels if SFX is playing noise
    // Y = 0
    a = noiseLock;
    if !zero {
        y = nonShadow_music;
    }
    zpTmp = y;

    a = voiceChannelsDirty_music & musicSfxChannelMask;
    __process_channels(a, zpTmp, volShadowDirty_tmp, globalVolume_music, FIRST_MUSIC_CHANNEL + 1, LAST_MUSIC_CHANNEL + 1);

    voiceChannelsDirty_music = voiceChannelsDirty_tmp;
}


inline func _process_sfx_channels__inline() {
    let BOTH_SFX_ACTIVE = (1 << 7) | (1 << 6);


    // No need to mask sfx keyOff/keyOn events.
    // The sfx channels do not emit key-off or key-on events when disabled.

    // Delay echo and noise changes 1 tick to prevent noise/echo changing in
    // the middle of the release envelope the channel is ducked or un-ducked.
    sfxMusicEchoNoiseMask = prevActiveSoundEffects;

    prevActiveSoundEffects = a = activeSoundEffects;

    // Update `musicSfxChannelMask`.
    // Music channels can only write to the S-DSP when the sound effect is disabled AND there is no key-off event.
    // Prevents an audio glitch when a music channel writes to a voice channel in the middle of the key-off release envelope.
    musicSfxChannelMask = a = (a | keyOffShadow_sfx) ^ 0xff;

    write_dsp(GlobalDspAddr.KOFF, keyOffShadow_sfx);


    y = pendingNon_sfx;
    if y != nonShadow_sfx {
        // SFX noise changed

        nonShadow_sfx = y;

        a = y;
        if zero {
            // Restore muted music channels on the next music tick when noiseLock is 0.
            voiceChannelsDirty_music |= nonShadow_music;
        }
        else {
            // A Sound effect wants to play noise but a music voice is also playing noise
            // and there is only one noise generator.
            //
            // To prevent a noise channel that doesn't have noiseLock from amplifying the
            // noiseLock channel's noise, all channels that do not own the noiseLock will
            // have their VxVOL zeroed.
            //
            // This is done in two places:
            //   1. At the start of `_process_sfx_channels__inline()` when a sound-effect
            //      wants to play noise, muting music noise before SFX noise starts.
            //      As an optimisation, this is only done if the previous SFX tick was not
            //      playing noise.
            //   2. When channelSoA.virtualChannels are written to the S-DSP.
            //      `sfxMutedChannels` mutes SFX channels and
            //      `nonShadow_music` mutes music channels (if `noiseLock` is non-zero).
            //
            //      This is required to:
            //        * Mute any future play_noise instructions.
            //        * Ignore any future volume changes
            //      on channels that do not have the `noiseLock`.
            x = noiseLock;
            if zero {
                a = nonShadow_music & musicSfxChannelMask;
                if !zero {
                    zpTmp = a;

                    // Assumes VoiceDspAddr.VOL_L == 0
                    // X = 0
                    y = a = x;

                    // Write 0 to VxVOLL and VxVOLR on all channels with `zpTmp` bit set.
                    do {
                        zpTmp >>>= 1;
                        if carry {
                            smp.dsp_addr_and_data = ya;
                            a++;
                            smp.dsp_addr_and_data = ya;
                            a--;

                            carry = false;
                        }
                        a +#= 0x10;

                        x = zpTmp;
                    } while !zero;

                    y = pendingNon_sfx;
                }
            }

            a = 0;
            if y >= BOTH_SFX_ACTIVE {
                // Both channels want to play noise but there's only 1 noise channel
                //
                // Decide which channel plays noise using the interruptible flag
                // and last SFX play_noise instruction.
                a = sfx_interruptibleFlags;
                goto UseLastPlayNoiseChannel if zero;
                    // 1 or 2 channels are interruptible.
                    // Invert interruptible flags
                    a ^= BOTH_SFX_ACTIVE;
                    // Test if both channels are uninterruptible
                    goto EndIf if !zero;
                        UseLastPlayNoiseChannel:
                            // Both channels are interruptible or uninterruptible.
                            // Use the SFX channel that last encountered a play_noise instruction.
                            a = lastSfxPlayNoiseChannel;
                EndIf:

                y = a;

                // Mute the other sfx channel
                // (eor used to swap bits 6 & 7 (since only 1 bit is set)
                a ^= BOTH_SFX_ACTIVE;
            }
        }

        // ::MAYDO replace with a MOVW write (If I can free 1 byte of zeropage)::
        noiseLock = y;
        sfxMutedChannels = a;

        // Mark muted SFX channel dirty to update VxVOL
        test_and_set(a, voiceChannelsDirty_sfx);
    }

    // Clears NON on the tick after key-off
    a = keyOffShadow_sfx;
    test_and_clear(a, pendingNon_sfx);


    volShadowDirty_tmp = volShadowDirty_sfx;

    a = 0;
    keyOffShadow_sfx = a;
    volShadowDirty_sfx = a;

    zpTmp = a = sfxMutedChannels;

    // DSP voice register writes must be masked
    a = voiceChannelsDirty_sfx & activeSoundEffects;

    __process_channels(a, zpTmp, volShadowDirty_tmp, globalVolume_sfx, FIRST_SFX_CHANNEL + 1, LAST_SFX_CHANNEL + 1);

    voiceChannelsDirty_sfx = voiceChannelsDirty_tmp;

    inline for let _I in 0..(N_SFX_CHANNELS - 1) {
        sfx_remainingTicks[_I]--;
    }
}


// Update the DSP voice registers, write to EON & KON, then execute channel bytecode.
//
// If a voice's `mutedChannels` and `voiceChannelsDirty` bit are both set, then
// 0 will be written to VxVOL.
//
// CAUTION: This function DOES NOT write to the `KOFF` S-DSP register.
//
// WARNING: self modifying code
func __process_channels(voiceChannelsDirty : u8 in a,
                        mutedChannels : u8 in zpTmp,
                        _volShadowDirty_tmp: u8 in volShadowDirty_tmp,
                        _globalVolume : u8 in globalVolume_tmp,
                        afterFirstChannel: u8 in y,
                        afterLastChannel: u8 in x) {
var _mutedChannels : u8 in zpTmp;

    // Modify the `CMP X, #` instruction argument for the two do-while loops
    // (faster and saves a byte of zeropage)
    (&_VoiceChannelLoop_cpx      as *u8)[1] = y;    // afterFirstChannel
    (&_BytecodeAndEffectLoop_cpx as *u8)[1] = x;    // afterLastChannel

    voiceChannelsDirty_tmp = a;

    // This loop MUST read the channels (and voiceChannelsDirty_tmp) in the opposite order
    // to the loop below this one.
    // That way I can populate `_voiceChannelsDirty_tmp` using `ROR` and read it with `ASL`.
    VoiceChannelLoop:
        x--;

        voiceChannelsDirty_tmp <<<= 1;
        if carry {
            a = LastVoiceRegister[x];

            // Voice registers are written in reverse order so the ADSR2/GAIN voice register is
            // written BEFORE the ADSR1 voice register.
            //
            // This prevents a race-condition that can occur when changing the envelope from ADSR to
            // GAIN (or vice versa).  If the race-condition occurs, the previous ADSR2/GAIN value is
            // erroneously used for a single sample.
            //
            // This race condition can affect multiple samples if the previous GAIN was a fixed
            // value and thus audible to the listener.

            y = channelSoA.virtualChannels.tempGain[x];
            if !zero {
                smp.dsp_addr_and_data = ya;

                y = 0;
            }
            else {
                // Need to test which register (ADSR2 or GAIN) to write to.
                y = channelSoA.virtualChannels.adsr1[x];
                if negative {
                    a--;
                }
                y = channelSoA.virtualChannels.adsr2OrGain[x];
                smp.dsp_addr_and_data = ya;

                y = channelSoA.virtualChannels.adsr1[x];
            }

            // A = GAIN (0x?7) or ADSR2 (0x?6)
            a &= 0b1111_0110;
            // A = 0x?6
            a--;
            // A = ADSR1 (0x?5)
            smp.dsp_addr_and_data = ya;

            a--;
            y = channelSoA.virtualChannels.scrn[x];
            smp.dsp_addr_and_data = ya;

            a--;
            y = channelSoA.virtualChannels.pitch_h[x];
            smp.dsp_addr_and_data = ya;

            a--;
            y = channelSoA.virtualChannels.pitch_l[x];
            smp.dsp_addr_and_data = ya;

            // Set VxVOL to 0 if _mutedChannels bit is set
            a--;
            y = _mutedChannels;
            if negative {
                y = 0;
                smp.dsp_addr_and_data = ya;
            }
            else {
                y = channelSoA.virtualChannels.vol_r[x];
                smp.dsp_addr_and_data = ya;

                y = channelSoA.virtualChannels.vol_l[x];
            }
            a--;
            smp.dsp_addr_and_data = ya;
        }

        _mutedChannels <<<= 1;

        // while x >= afterFirstChannel
    _VoiceChannelLoop_cpx:
        cmp(x, 0);
        goto VoiceChannelLoop if carry;

    // X = 0 or 8 (first channel index)


    y = a = ((eonShadow_music ^ eonShadow_sfx) & sfxMusicEchoNoiseMask) ^ eonShadow_music;
    write_dsp(GlobalDspAddr.EON, y);

    y = a = (nonShadow_music & musicSfxChannelMask) | nonShadow_sfx;
    write_dsp(GlobalDspAddr.NON, y);


    // Setting noise frequency after voice registers are written
    // so SFX noise frequency is set after SFX VxVOL is zeroed or restored.
    //
    // Comparing X with 0 is faster then splitting `__process_channels()` into two separate functions
    a = x;
    if zero {
        // processing music channels

        write_dsp(GlobalDspAddr.PMON, pmonShadow);

        a = noiseLock;
        if zero {
            // Assumes noiseFreq_music is <= dsp.FLG__NOISE_FREQ_MASK.
            write_dsp(GlobalDspAddr.FLG, noiseFreq_music);
        }

        y = a = keyOnShadow_music & musicSfxChannelMask & io_musicChannelsMask;

        // X = 0
        keyOnShadow_music = x;
    }
    else {
        // processing sound-effect channels

        a = noiseLock;
        if !zero {
            if negative {
                y = noiseFreq_sfx[1];
            }
            else {
                y = noiseFreq_sfx[0];
            }
            // Assumes noiseFreq_sfx is <= dsp.FLG__NOISE_FREQ_MASK.
            write_dsp(GlobalDspAddr.FLG, y);
        }

        y = keyOnShadow_sfx;
        keyOnShadow_sfx = 0;
    }
    write_dsp(GlobalDspAddr.KON, y);


    // X = 0 or 8
    BytecodeAndEffectLoop:
        // MUST NOT use `_konShadow` and `_afterFirstChannel` in this loop.
        // The are clobbered by pitch effects and bytecode.


        voiceChannelsDirty_tmp >>>= 1;

        // Vibrato is processed before bytecode.
        // This delays all pitch changes 1 tick after a play-note instruction
        // and ensures the first pitch on a play-note instruction is the requested note.
        _process_vibrato__inline(x);

        // Must saturate-increment on every tick.
        // The note could be a part of a `play-note nokeyoff | rest` chain.
        a = channelSoA.ticksAfterNote[x];
        a++;
        if zero {
            a--;
        }
        channelSoA.ticksAfterNote[x] = a;

        channelSoA.countdownTimer[x]--;
        if !zero {
            // Check for early-release
            y = channelSoA.nextEventIsKeyOff[x];
            if !zero {
                // Do not early-release if the note has been playing for min-ticks
                if a >= channelSoA.earlyRelease_minTicks[x] {
                    // Must be a `<` comparison (not a `==`)
                    // Ensures notes shorter than early-release are cut at the correct time.
                    a = channelSoA.countdownTimer[x];
                    if a < channelSoA.earlyRelease_cmp[x] {
                        a = channelSoA.earlyRelease_gain[x];
                        if !zero {
                            channelSoA.virtualChannels.tempGain[x] = a;

                            voiceChannelsDirty_tmp $ 7 = true;
                        }
                        else {
                            // ::TODO deduplicate::
                            a = ChannelVoiceBit[x];
                            if x >= FIRST_SFX_CHANNEL {
                                test_and_set(a, keyOffShadow_sfx);
                                test_and_set(a, keyOnMask_sfx);
                            }
                            else {
                                test_and_set(a, keyOffShadow_music);
                                test_and_set(a, keyOnMask_music);
                            }
                        }
                    }
                }
            }
        }
        else {
            // Check if a KEY_OFF is required
            a = channelSoA.nextEventIsKeyOff[x];
            if !zero {
                a = ChannelVoiceBit[x];
                if x >= FIRST_SFX_CHANNEL {
                    test_and_set(a, keyOffShadow_sfx);
                    test_and_set(a, keyOnMask_sfx);
                }
                else {
                    test_and_set(a, keyOffShadow_music);
                    test_and_set(a, keyOnMask_music);
                }

                a = 0;
                // schedule a bytecode event
                channelSoA.nextEventIsKeyOff[x] = a;
                // Disable temp gain
                channelSoA.virtualChannels.tempGain[x] = a;

                // Previous countdownTimer value was 0
                channelSoA.countdownTimer[x]++;
            }
            else {
                y = channelSoA.instructionPtr_h[x];
                if !zero {
                    a = channelSoA.instructionPtr_l[x];
                    process_bytecode(x, ya);

                    ya = instructionPtr as u16;
                    channelSoA.instructionPtr_l[x] = a;
                    channelSoA.instructionPtr_h[x] = y;

                    // Request S-DSP voice register update (set dirty bit).
                    // The bytecode most likely changed the virtual channel.
                    //
                    // The flag is set here (and once) instead of every instruction that changes
                    // `channelSoA.virtualChannels` to save a lot of code space.
                    //
                    voiceChannelsDirty_tmp $ 7 = true;
                }
            }
        }

        a = channelSoA.volEffect_direction[x];
        if !zero {
            _process_volume_effects__inline(x, a);

            // ::TODO optimise::
            // Set S-DSP voice registers dirty bit
            voiceChannelsDirty_tmp $ 7 = true;

            volShadowDirty_tmp $ 7 = true;
        }

        a = channelSoA.panEffect_direction[x];
        if !zero {
            _process_pan_effects__inline(x, a);

            // ::TODO optimise::
            // Set S-DSP voice registers dirty bit
            voiceChannelsDirty_tmp $ 7 = true;

            volShadowDirty_tmp $ 7 = true;
        }


        // Cannot do this after process_bytecode() for 2 reasons:
        //  1. Volume must be calculated on the first instruction of a sound-effect
        //  2. Volume/pan slide/vibrato
        volShadowDirty_tmp <<<= 1;
        if carry {
            _update_vol_shadow__inline(x);
        }

        // Portamento is processed after bytecode to ensure pitch slide occurs
        // on the same tick as the portamento instruction.
        _process_portamento__inline(x);

        x++;
        // while x < afterLastChannel
    _BytecodeAndEffectLoop_cpx:
        cmp(x, 0);
        ^goto BytecodeAndEffectLoop if !carry;
}


// Write echo variables to the S-DSP echo registers if the `echoDirty` bits are set
inline func _process_echo_registers__inline() {
    a = echoDirty;
    if !zero {
        // assumes ECHO_DIRTY__FIR_FILTER_BIT == 7
        if negative {
            y = 0;

            // assumes ECHO_DIRTY__CLEAR_FIR_BIT == 0
            a >>>= 1;
            if carry {
                // Clear FIR filter
                carry = false;
                a = GlobalDspAddr.C0 as u8;
                do {
                    // Y = 0
                    write_dsp(a as GlobalDspAddr, y);

                    // Assumes GlobalDspAddr.C1 - GlobalDspAddr.C0 == 0x10
                    // Assumes GlobalDspAddr.C7 + 0x10 >= 0x80
                    a +#= 0x10;
                } while !negative;
            }

            smp.dsp_addr = GlobalDspAddr.C0 as u8;
            // carry clear
            // Y = 0
            do {
                // EchoBufferSettings.firFilter
                smp.dsp_data = a = echo.firFilter[y] as u8;
                y++;

                // Assumes GlobalDspAddr.C1 - GlobalDspAddr.C0 == 0x10
                // Assumes GlobalDspAddr.C7 + 0x10 >= 0x80
                smp.dsp_addr += 0x10;
            } while !negative;

            a = echoDirty;
        }

        // Assumes ECHO_DIRTY__VOLUME_BIT == 6
        a <<<= 1;
        if negative {
            smp.dsp_addr = GlobalDspAddr.EVOL_L as u8;

            a = echo.echoVolume_l;

            // Reading carry here saves a `CLC` instruction when averaging echo volumes
            carry = loaderDataType $ LoaderDataType.STEREO_FLAG_BIT;
            if !carry {
                // Mono

                // Calculate average echo volume.
                // Assumes echoVolume_l and echoVolume_r are both > 127.
                a = (a +# echo.echoVolume_r) >>> 1;

                // Cannot use bbc instruction in wiz
                carry = echo.invertFlags $ INVERT_FLAGS.MONO_BIT;
                if carry {
                    a ^= 0xff;
                    a++;
                }
                smp.dsp_data = a;
            }
            else {
                carry = echo.invertFlags $ INVERT_FLAGS.LEFT_BIT;
                if carry {
                    a ^= 0xff;
                    a++;
                }
                smp.dsp_data = a;

                a = echo.echoVolume_r;
                carry = echo.invertFlags $ INVERT_FLAGS.RIGHT_BIT;
                if carry {
                    a ^= 0xff;
                    a++;
                }
            }
            // a = evol_r

            // Assumes GlobalDspAddr.EVOL_R = GlobalDspAddr.EVOL_L | 0x10
            smp.dsp_addr $ 4 = true;
            smp.dsp_data = a;
        }

        // Always update echo feedback
        smp.dsp_addr = GlobalDspAddr.EFB as u8;
        smp.dsp_data = echo.echoFeedback as u8;

        // Always update echo delay
        smp.dsp_addr = GlobalDspAddr.EDL as u8;
        smp.dsp_data = echo.edl;

        echoDirty = 0;
    }
}


// IO Ports
// ========

namespace io_commands {

inline func init__inline() {
    // Assumes audio driver starts paused.
    // Assumes IO.Command.PAUSE is 0
    // Assumes `IO.ToDriver.command` is non-zero from the loader.

    a = IO.Command.PAUSE as u8;
    IO.ToScpu.command_ack = a;
    previousCommand = a;
}


inline func process_io_ports__inline() {
    // If the S-CPU writes to an IO port at the same time S-SMP reads from the
    // same IO port, the S-SMP will read invalid data.
    //
    // To detect this bug the IO-Port is read twice and the command is only
    // processed if both reads are the same.
    //
    // Once the command byte has been read successfully, the two parameter bytes
    // do not need to be double-read because:
    //  * The S-CPU will wait until the command has been acknowledged before
    //    writing a new command
    //  * The parameter bytes are written before the command byte is written.

    // Test if `IO.command_id` has changed.
    a = IO.ToDriver.command;
    if a != previousCommand {
        if a == IO.ToDriver.command {
            push(a);

            // MUST set previousCommand before executing command
            // (`pause()` changes previousCommand)
            previousCommand = a;

            y = IO.ToDriver.parameter0;
            __call_command(a, y);

            // Acknowledge command
            a = pop();
            IO.ToScpu.command_ack = a;
        }
    }


    // Execute the loader if the _SWITCH_TO_LOADER_BIT is set.
    //
    // (cannot use `bbc` instructions in wiz, using two `MOV1 ; bcc` instructions instead)
    carry = IO.ToDriver.switch_to_loader $ IO.ToDriver._SWITCH_TO_LOADER_BIT;
    if carry {
        // Read the IO port a second time just in case it was a glitch
        carry = IO.ToDriver.switch_to_loader $ IO.ToDriver._SWITCH_TO_LOADER_BIT;
        if carry {
            ^goto (LOADER_ADDR as func);
        }
    }
}


// NOTE: Does not acknowledge command
func __call_command(command : u8 in a, parameter : u8 in y) {
    a &= IO.ToDriver.COMMAND_MASK;
    if a < sizeof(typeof(CommandFunctionTable)) {
        x = a;
        goto CommandFunctionTable[unaligned x];
    }
}


// MUST match `Command` enum in `io-commands.wiz`
const CommandFunctionTable : [func(parameter0: u8 in y) ; IO.ToDriver.N_COMMANDS] = [
    pause as func(u8 in y),
    pause_music_play_sfx as func(u8 in y),
    unpause as func(u8 in y),
    play_sound_effect,
    stop_sound_effects,
    set_main_volume,
    set_music_channels,
    set_song_timer,
    set_global_music_volume,
    set_global_sfx_volume,
    set_global_volumes,
];


// Pause music and sound effects
func pause() {
    // Disable timers
    smp.control = 0;

    // Reset counters to fix a music/sfx channel playing a single tick after a `pause` IO command.
    // (clears counter_0 and counter_1)
    ya = *(&smp.counter_0 as *u16);

    // key-off all channels
    return __keyoff(0xff);
}


#[fallthrough]
func pause_music_play_sfx() {
    // Disable music timer, enable sfx timer
    smp.control = smp.CONTROL__ENABLE_TIMER_1;

    // Reset counter to fix music channel playing a single tick after a `pause_music_play_sfx` IO command.
    a = smp.counter_0;

    y = musicSfxChannelMask; // key-off music channels

// fallthrough into __keyoff()
}

func __keyoff(channelsMask: u8 in y) {
    write_dsp(GlobalDspAddr.KOFF, y);
}


func unpause() {
    // Enable music and sfx timers
    smp.control = smp.CONTROL__ENABLE_TIMER_0 | smp.CONTROL__ENABLE_TIMER_1;
}


func set_main_volume(volume : u8 in y) {
    write_dsp(GlobalDspAddr.MVOL_L, y);
    write_dsp(GlobalDspAddr.MVOL_R, y);
}


func set_music_channels(mask : u8 in y) {
    io_musicChannelsMask = y;

    // key-off muted channels
    a = y ^ 0xff;
    test_and_set(a, keyOffShadow_music);
}


func set_song_timer(timer : u8 in y) {
    // if (y > 0 && y < MIN_TICK_CLOCK) y = MIN_TICK_CLOCK
    y--;
    if y < MIN_TICK_CLOCK - 1 {
        y = MIN_TICK_CLOCK - 1;
    }
    y++;
    smp.timer_0 = y;
}


func set_global_music_volume(volume: u8 in y) {
    // Increment volume so maximum volume is 0
    y++;
    globalVolume_music = y;

    volShadowDirty_music = 0xff;
}


#[fallthrough]
func set_global_volumes(musicVolume: u8 in y) {
    set_global_music_volume(y);

    y = IO.ToDriver.parameter1;
// Fallthrough into set_global_sfx_volume()
}


func set_global_sfx_volume(volume: u8 in y) {
    // Increment volume so maximum volume is 0
    y++;
    globalVolume_sfx = y;

    volShadowDirty_sfx = 0b11000000;
}


func stop_sound_effects(unused : u8 in y) {
    // Assumes 2 sound effect channels

    // `disable_channel` does not write to channelSoa.instructionPtr*.
    channelSoA.instructionPtr_h[FIRST_SFX_CHANNEL] = 0;
    channelSoA.instructionPtr_h[LAST_SFX_CHANNEL] = 0;

    bytecode.disable_channel(FIRST_SFX_CHANNEL);
    ^return bytecode.disable_channel(LAST_SFX_CHANNEL);
}


func play_sound_effect(sfx_id : u8 in y) {
    let BOTH_SFX_ACTIVE = (1 << 7) | (1 << 6);

    if y < commonDataHeader.nSoundEffects {
        goto _maybe_restart_sfx_0 if y == sfx_oneChannelSfxId[0];
        goto _maybe_restart_sfx_1 if y == sfx_oneChannelSfxId[1];

        a = activeSoundEffects;
        goto __play_sfx__both_channels_active if a >= BOTH_SFX_ACTIVE;

        // At most 1 sound effect channel is active
        a <<<= 1;
        goto _play_sfx_1 if !carry;
        goto _play_sfx_0;
    }
}


#[fallthrough]
func __play_sfx__both_channels_active(sfx_id : u8 in y) {
    let BOTH_SFX_ACTIVE = (1 << 7) | (1 << 6);

    // Both sound effect channels are active,

    // Drop sfx_id if it is a low-priority sound effect
    if y < commonDataHeader.firstLowPrioritySfx {
        a = sfx_interruptibleFlags;
        if (zero && y < commonDataHeader.nHighPrioritySfx) || a >= BOTH_SFX_ACTIVE {
            // Both sound effect channels active and either:
            //   * both uninterruptible and sfx_id is high-priority
            //   * both interruptible and sfx_id is normal priority
            //
            // check remaining ticks and drop the sound effect that will finish first.

            // Assumes 2 sound effect channels
            ya = sfx_remainingTicks[0];
            cmp(ya, sfx_remainingTicks[1]);

            y = IO.ToDriver.parameter0;
            goto _play_sfx_0 if !carry;
            goto _play_sfx_1;
        }

        // Play sound effect if a channel is interruptible
        a <<<= 1;
        goto _play_sfx_1 if carry;
        goto _play_sfx_0 if negative;
    }

// Fallthrough
}

func __play_sfx_return() {
    return;
}

// returns soundEffects_addrAndOneChannelFlag_h
inline func __play_sfx__inline(let _I : u8, sfx_id : u8 in y) : u8 in a {
    let BIT = 8 - N_SFX_CHANNELS + _I;

    <:sfx_remainingTicks[_I] = a = commonData.soundEffects_durationAndInterruptFlag_l[y];
    >:sfx_remainingTicks[_I] = a = commonData.soundEffects_durationAndInterruptFlag_h[y];

    a <<<= 1;
    sfx_interruptibleFlags $ BIT = carry;


    sfx_oneChannelSfxId[_I] = y;

    a = commonData.soundEffects_addrAndOneChannelFlag_h[y];
    if !negative {
        sfx_oneChannelSfxId[_I] = 0xff;
    }
    return a;
}


// Restart sfx channel 0 if it is interruptible
// ASSUMES: sfx_id == sfx_oneChannelSfxId[0]
#[fallthrough]
func _maybe_restart_sfx_0(sfx_id : u8 in y) {}
    // HACK: wiz does not support bbc instructions.
    // Manually writing a `bbc` instruction that branches to `__play_sfx_return` if the sfx is not interruptible.
    const __maybe_restart_sfx_0 : [u8 ; 3] = [
        // bbc sfx_interruptibleFlags.6 __play_sfx_return
        0x13 | (6 << 5) as u8,
        &sfx_interruptibleFlags as u8,
        (&__play_sfx_return as i16 - &__maybe_restart_sfx_0 as i16 - 3) as u8
    ];

func _play_sfx_0(sfx_id : u8 in y) {
    a = __play_sfx__inline(0, y);
    return __play_sfx_on_channel(a, FIRST_SFX_CHANNEL, y);
}



// Restart sfx channel 1 if it is interruptible
// ASSUMES: sfx_id == sfx_oneChannelSfxId[1]
#[fallthrough]
func _maybe_restart_sfx_1(sfx_id : u8 in y) {}
    // HACK: wiz does not support bbc instructions.
    // Manually writing a `bbc` instruction that branches to `__play_sfx_return` if the sfx is not interruptible.
    const __maybe_restart_sfx_1 : [u8 ; 3] = [
        // bbc sfx_interruptibleFlags.7 __play_sfx_return
        0x13 | (7 << 5) as u8,
        &sfx_interruptibleFlags as u8,
        (&__play_sfx_return as i16 - &__maybe_restart_sfx_1 as i16 - 3) as u8
    ];

#[fallthrough]
func _play_sfx_1(sfx_id : u8 in y) {
    a = __play_sfx__inline(1, y);
    x = LAST_SFX_CHANNEL;
// Fallthrough
}


// ASSUMES: sfx_id < commonData.nSoundEffects
// KEEP: X
#[fallthrough]
func __play_sfx_on_channel(addrAndOneChannelFlag_h: u8 in a, channelIndex : u8 in x, sfx_id : u8 in y) {
    channelSoA.instructionPtr_h[x] = a = a & 0x7f;
    channelSoA.instructionPtr_l[x] = a = commonData.soundEffects_addrAndOneChannelFlag_l[y];

    a = ChannelVoiceBit[x];
    // Send a key-off event, the S-DSP voice channel might be active.
    test_and_set(a, keyOffShadow_sfx);
    // Set keyOnMask.  The next play-note instruction will queue a KON event.
    test_and_set(a, keyOnMask_sfx);
    // Disable echo
    test_and_clear(a, eonShadow_sfx);

    // Not disabling noise.
    // Clearing pendingNon_sfx would disable noise in the middle of the release envelope.
    // Noise will be disabled after the key-off release envelope.

    // Enable sfx channel.
    test_and_set(a, activeSoundEffects);

    // Mark sfx channel volume dirty
    // eor used to swap bits 6 & 7 (since only 1 bit is set)
    a ^= 0b11_000000;
    test_and_set(a, volShadowDirty_sfx);


    // pan
    a = IO.ToDriver.parameter1;

// Fallthrough into __reset_channel()
}

}

// NOTE: Does not set:
//  * channelSoA.instructionPtr
//  * instrument/envelope
//  * virtual channels
//  * keyOnMask
//  * eonShadow
//  * nonShadow
//
// KEEP: X
func __reset_channel(channelIndex : u8 in x, pan: u8 in a) {
    // MUST NOT use `commonData`.
    // (It contains song header data, not common-audio data)

    direct_page = true;
    // MUST NOT access zeropage variables until direct_page is false.
    {
        // Hack to allow access to firstpage channelSoA variables with `direct_page = true`.
        var _cs_pan                 @ &channelSoA.pan as u8                 : [u8 ; N_CHANNELS];
        var _cs_volume              @ &channelSoA.volume as u8              : [u8 ; N_CHANNELS];
        var _cs_panEffect_direction @ &channelSoA.panEffect_direction as u8 : [u8 ; N_CHANNELS];
        var _cs_volEffect_direction @ &channelSoA.volEffect_direction as u8 : [u8 ; N_CHANNELS];
        var _cs_earlyRelease_cmp    @ &channelSoA.earlyRelease_cmp as u8    : [u8 ; N_CHANNELS];
        var _cs_invertFlags         @ &channelSoA.invertFlags as u8         : [u8 ; N_CHANNELS];
        var _cs_detune_l            @ &channelSoA.detune_l as u8            : [u8 ; N_CHANNELS];
        var _cs_detune_h            @ &channelSoA.detune_h as u8            : [u8 ; N_CHANNELS];

        _cs_pan[x] = a = pan;
        _cs_volume[x] = a = STARTING_VOLUME;


        a = 0;

        // Disable pan effects
        _cs_panEffect_direction[x] = a;

        // Disable volume effects
        _cs_volEffect_direction[x] = a;

        // Disable channel invert
        _cs_invertFlags[x] = a;

        // Disable early-release
        _cs_earlyRelease_cmp[x] = a;
            // No need to reset `earlyRelease_minTicks`,
            // (Early release is not active if `earlyRelease_cmp == 0`)

        // Reset detune
        _cs_detune_l[x] = a;
        _cs_detune_h[x] = a;

        channelSoA.transpose[x] = a;
    }
    direct_page = false;


    // Disable temp-gain
    channelSoA.virtualChannels.tempGain[x] = a;

    // Disable portamento
    channelSoA.portamento_direction[x] = a as i8;

    // Disable vibrato
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;


    // Immediately process bytecode on the next tick
    channelSoA.nextEventIsKeyOff[x] = a; // a = 0
    a++;
    channelSoA.countdownTimer[x] = a;    // a = 1


    channelSoA.stackPointer[x] = a = BcStackIndexesStart[x];

    // Ensures loopStackPointer is in-bounds if the first instruction is `end_loop`.
    channelSoA.loopStackPointer[x] = a = a - 3;
}


// Volume and Pan
// ==============


// Process volume effect
//
// CAUTION: Does not set `volShadowDirty_tmp`.
//
// KEEP: x
inline func _process_volume_effects__inline(channelIndex: u8 in x, direction: u8 in a) {
    // Warning spaghetti code: Optimised for code-size.

    // Hack to allow access to volume effect variables with `direct_page = true`.
    var _csv_volume         @ &channelSoA.volume                    as u8 : [u8 ; N_CHANNELS];
    var _csv_subVolume      @ &channelSoA.subVolume                 as u8 : [u8 ; N_CHANNELS];
    var _csv_direction      @ &channelSoA.volEffect_direction       as u8 : [u8 ; N_CHANNELS];
    var _csv_counter        @ &channelSoA.volEffect_counter         as u8 : [u8 ; N_CHANNELS];
    var _csv_offset_l       @ &channelSoA.volEffect_offset_l        as u8 : [u8 ; N_CHANNELS];
    var _csv_offset_h       @ &channelSoA.volEffect_offset_h        as u8 : [u8 ; N_CHANNELS];
    var _csv_halfWavelength @ &channelSoA.volEffect_halfWavelength  as u8 : [u8 ; N_CHANNELS];

    a >>>= 1;

    direct_page = true;
    // MUST NOT access zeropage variables until direct_page is false.

    a = _csv_subVolume[x];
    y = _csv_volume[x];

    goto Up if !carry;
        // down
        // carry set
        a -#= _csv_offset_l[x];
        _csv_subVolume[x] = a;

        a = y -# _csv_offset_h[x];

        goto EndIf if carry;
            y = 0;
            goto DisableEffect;

        UpOverflow:
            y = 0xff;
        DisableEffect:
            a = 0;
            goto WriteDirection;

    Up:
        // up
        // carry clear
        a +#= _csv_offset_l[x];
        _csv_subVolume[x] = a;

        a = y +# _csv_offset_h[x];

        goto UpOverflow if carry;
EndIf:

    y = a;

    _csv_counter[x]--;
    goto WriteVolume if !zero;

        a = _csv_halfWavelength[x];
        if !zero {
            _csv_counter[x] = a;

            // Change direction
            a = _csv_direction[x] ^ 1;
        }
    WriteDirection:
        _csv_direction[x] = a;

WriteVolume:
    _csv_volume[x] = y;

    direct_page = false;
}


// Process pan effect
//
// CAUTION: Does not set `volShadowDirty_tmp`.
//
// KEEP: x
inline func _process_pan_effects__inline(channelIndex: u8 in x, direction: u8 in a) {
    // Warning spaghetti code: Optimised for code-size.

    // Hack to allow access to pan effect variables with `direct_page = true`.
    var _csp_pan            @ &channelSoA.pan                       as u8 : [u8 ; N_CHANNELS];
    var _csp_subPan         @ &channelSoA.subPan                    as u8 : [u8 ; N_CHANNELS];
    var _csp_direction      @ &channelSoA.panEffect_direction       as u8 : [u8 ; N_CHANNELS];
    var _csp_counter        @ &channelSoA.panEffect_counter         as u8 : [u8 ; N_CHANNELS];
    var _csp_offset_l       @ &channelSoA.panEffect_offset_l        as u8 : [u8 ; N_CHANNELS];
    var _csp_offset_h       @ &channelSoA.panEffect_offset_h        as u8 : [u8 ; N_CHANNELS];
    var _csp_halfWavelength @ &channelSoA.panEffect_halfWavelength  as u8 : [u8 ; N_CHANNELS];

    direct_page = true;
    // MUST NOT access zeropage variables until direct_page is false.

    a >>>= 1;

    y = _csp_pan[x];

    a = _csp_subPan[x];

    goto Up if !carry;
        // down
        // carry set
        a -#= _csp_offset_l[x];
        _csp_subPan[x] = a;

        a = y -# _csp_offset_h[x];

        goto EndIf if carry;
            y = 0;
            goto DisableEffect;

        UpOverflow:
            y = MAX_PAN;
        DisableEffect:
            a = 0;
            goto WriteDirection;

    Up:
        // up
        // carry clear
        a +#= _csp_offset_l[x];
        _csp_subPan[x] = a;

        a = y +# _csp_offset_h[x];

        goto UpOverflow if carry || a >= (MAX_PAN + 1);
EndIf:

    y = a;

    _csp_counter[x]--;
    goto WritePan if !zero;

        a = _csp_halfWavelength[x];
        if !zero {
            _csp_counter[x] = a;

            // Change direction
            a = _csp_direction[x] ^ 1;
        }
    WriteDirection:
        _csp_direction[x] = a;

WritePan:
    _csp_pan[x] = y;

    direct_page = false;
}


// Updates vol_l and vol_r shadow variables.
//
// KEEP: x
inline func _update_vol_shadow__inline(channelIndex : u8 in x) {

    // If global-volume is 0, the channel volume is unchanged.
    y = a = channelSoA.volume[x];
    a = globalVolume_tmp;
    if !zero {
        ya = mul(a, y);
    }
    // Y = volume

    // Reading carry here saves a `SEC` instruction when calculating VOL_R
    carry = loaderDataType $ LoaderDataType.STEREO_FLAG_BIT;
    if !carry {
        // Mono

        // First shift converts 8-bit volume to 7-bit VOL
        // Second shift ensure mono vol has same combined amplitude as stereo vol
        y = a = y >>> 2;

        // Test mono flag
        a = channelSoA.invertFlags[x] & INVERT_FLAGS.MONO;
        if !zero {
            // Invert Y
            a = y ^ 0xff;
            a++;
            y = a;
        }

        channelSoA.virtualChannels.vol_r[x] = y;
        // vol_l set after if
    }
    else {
        // Stereo
        // carry set

        zpTmp = y;

        // Calculate right volume
        // A pan value of `MAX_PAN` is 100% to the right.
        // (MUST NOT USE CARRY)

        a = channelSoA.pan[x];
        ya = mul(a, y);

        a = channelSoA.invertFlags[x];
        if negative {
            // Invert Y
            a = y ^ 0xff;
            a++;
            y = a;
        }
        channelSoA.virtualChannels.vol_r[x] = y;

        // Calculate left volume
        // A pan value of `0` is 100% to the left.

        // Carry set (MUL does not set carry)
        a = MAX_PAN -# channelSoA.pan[x];
        y = zpTmp;
        ya = mul(a, y);

        a = channelSoA.invertFlags[x];
        a <<<= 1;
        if negative {
            // Invert Y
            // (have to invert Y, no 65816-style `bit invertFlags,x` instruction)
            a = y ^ 0xff;
            a++;
            y = a;
        }
    }

    channelSoA.virtualChannels.vol_l[x] = y;
}



// Pitch Effects
// =============


// KEEP: X
inline func _process_vibrato__inline(channelIndex : u8 in x) {
    // Hack to allow access to volume effect variables with `direct_page = true`.
    var _dp_csv_tickCounter      @ &channelSoA.vibrato_tickCounter    as u8 : [u8 ; N_CHANNELS];
    var _dp_csv_halfWavelength   @ &channelSoA.vibrato_halfWavelength as u8 : [u8 ; N_CHANNELS];


    // (vibrato is not active during portamento)
    y = channelSoA.portamento_direction[x] as u8;
    if zero {
        // Vibrato is disabled if pitch-offset-per-tick is 0
        y = channelSoA.vibrato_pitchOffsetPerTick[x];
        if !zero {
            a = channelSoA.ticksAfterNote[x];
            if a >= channelSoA.vibrato_delay[x] {

                a = channelSoA.vibrato_direction[x] as u8;
                a >>>= 1;

                if !carry {
                    // Add Y to pitch_l
                    // carry clear
                    a = y +# channelSoA.virtualChannels.pitch_l[x];
                    if carry {
                        channelSoA.virtualChannels.pitch_h[x]++;
                    }
                }
                else {
                    // Subtract pitchOffsetPerTick from pitch_l
                    // (uses 1 less byte than reverse subtract Y, with the same CPU cycle count)
                    // carry set
                    a = channelSoA.virtualChannels.pitch_l[x] -# channelSoA.vibrato_pitchOffsetPerTick[x];
                    if !carry {
                        channelSoA.virtualChannels.pitch_h[x]--;
                    }
                }

                channelSoA.virtualChannels.pitch_l[x] = a;

                direct_page = true;

                _dp_csv_tickCounter[x]--;
                if zero {
                    _dp_csv_tickCounter[x] = a = _dp_csv_halfWavelength[x];

                    direct_page = false;

                    channelSoA.vibrato_direction[x]++;
                }
                direct_page = false;

                // Set S-DSP voice registers dirty bit
                voiceChannelsDirty_tmp $ 7 = true;
            }
        }
    }
}


// KEEP: X
inline func _process_portamento__inline(channelIndex : u8 in x) {
var _target_h : u8 in zpTmp;

    // Warning: spaghetti code

    a = channelSoA.portamento_direction[x] as u8;
    if !zero {
        // Portamento

        if negative {
            // portamento down

            // Save target_h for later (no `cpy dp,x` instruction)
            _target_h = a = channelSoA.portamento_target_h[x];

            // Update pitch
            a = channelSoA.virtualChannels.pitch_l[x];
            y = channelSoA.virtualChannels.pitch_h[x];

            // Subtract speed from pitch
            a -= channelSoA.portamento_speed[x];
            if !carry {
                y--;
                // Test for underflow
                goto MetTarget if negative;
            }

            // Test pitch against target
            cmp(y, _target_h);
            if zero {
                cmp(a, channelSoA.portamento_target_l[x]);
            }
            goto WritePitchRegisters if carry;
        }
        else {
            // portamento up

            // Save target_h for later (no `cpy dp,x` instruction)
            _target_h = a = channelSoA.portamento_target_h[x];

            a = channelSoA.virtualChannels.pitch_l[x];
            y = channelSoA.virtualChannels.pitch_h[x];

            // Add speed to pitch
            a += channelSoA.portamento_speed[x] as u8;
            if carry {
                y++;
                // PITCH is 14 bits long, no overflow test required.
            }

            // Test pitch against target
            cmp(y, _target_h);
            if zero {
                cmp(a, channelSoA.portamento_target_l[x]);
            }
            goto WritePitchRegisters if !carry;
        }

        // Pitch reached or exceeded target
    MetTarget:
        // Disable portamento
        a = 0;
        channelSoA.portamento_direction[x] = a as i8;

        // Restart vibrato (if active)
        // A = 0
        channelSoA.vibrato_direction[x] = a;
        channelSoA.vibrato_tickCounter[x] = a = channelSoA.vibrato_tickCounterStart[x];

        a = channelSoA.portamento_target_l[x];
        y = _target_h;

    WritePitchRegisters:
        // ya = new pitch
        channelSoA.virtualChannels.pitch_l[x] = a;
        channelSoA.virtualChannels.pitch_h[x] = y;

        // Set S-DSP voice registers dirty bit
        voiceChannelsDirty_tmp $ 7 = true;
    }
}


// Process Bytecode
// ================
//
// bytecode functions MUST NOT modify X.
//
// bytecode functions MUST NOT modify S-DSP registers.


// See `process_bytecode_with_loader_test()`.
func __bbs_loader_bit_set(channelIndex : u8 in x, addr : u16 in ya) {
    // Test the SWITCH_TO_LOADER_BIT a second time (just to be safe) before switching to the loader

    // (cannot use `bbc` instructions in wiz, using an `MOV1 ; bcc` instruction instead)
    carry = IO.ToDriver.switch_to_loader $ IO.ToDriver._SWITCH_TO_LOADER_BIT;
    goto process_bytecode if !carry;

    ^goto (LOADER_ADDR as func);
}


// Set the bytecode `instructionPtr` and execute the next bytecode instruction while also
// testing the if `_SWITCH_TO_LOADER_BIT` bit is set.
//
// If the `_SWITCH_TO_LOADER_BIT` bit is set, the audio driver stops execution and the loader is
// started.  This should hopefully ensure the loader will be executed if the bytecode goes off the
// rails and never sleeps.
//
// KEEP: X
//
#[fallthrough]
func process_bytecode_with_loader_test(channelIndex : u8 in x, addr : u16 in ya) {
}

// HACK: wiz does not support bbs instructions.
// Manually writing a `bbs` instruction that branches to `__bbs_loader_bit_set` if the
// _SWITCH_TO_LOADER_BIT is set. Otherwise, falls through into the `process_bytecode` instruction.
const __process_bytecode_with_loader_test : [u8 ; 3] = [
    0x3 | (IO.ToDriver._SWITCH_TO_LOADER_BIT << 5) as u8,                                   // bbs
    &IO.ToDriver.switch_to_loader as u8,                                                    // addr
    (&__bbs_loader_bit_set as i16 - &__process_bytecode_with_loader_test as i16 - 3) as u8  // rel
];



// Set the bytecode `instructionPtr` and execute the next bytecode instruction.
// KEEP: X
#[fallthrough]
func process_bytecode(channelIndex : u8 in x, addr : u16 in ya) {
    instructionPtr = ya as *const u8;

// Fallthrough
}


// Execute the next bytecode instruction
//
// KEEP: X
func process_next_bytecode(channelIndex : u8 in x) {

    y = 0;
    a = instructionPtr[y];
    instructionPtr++;

    goto bytecode._play_note if a >= bytecode.InstructionTable.len;

    // A is a non play-note bytecode
    y = a = a <<<= 1;

    // Push return address to the stack.
    //
    // This method uses the same number of CPU cycles (and the least amount of code space) compared to:
    //   * `JMP[!abs+X]` plus saving/restoring X via a zeropage register (as there is no `TXY` or `TXY` instruction
    //   * self modifying code (writing the return address of a JMP instruction)
    //
    push(a = (&>:bytecode.InstructionTable[0] as *u8)[y]);
    push(a = (&<:bytecode.InstructionTable[0] as *u8)[y]);

    if y < bytecode.FIRST_NO_ARGUMENT_INSTRUCTION_OPCODE * 2 {
        // Instruction has a parameter
        y = 0;
        a = instructionPtr[y];
        instructionPtr++;
    }

    // Y MUST be 0 if the instruction has an argument

    // Jump to the bytecode instruction routine that was just pushed onto the stack.
    return;
}



// NOTE: BYTECODE INSTRUCTIONS MUST KEEP X
//
// NOTE: If the instruction has an argument, Y will be 0
//
// Bytecode instruction must either:
//    * Return after setting `channelSoA.nextEvent_*` (to start sleeping)
//    * Jump to `process_next_bytecode` to execute the next bytecode instruction
//    * Jump to `process_bytecode` to change the bytecode instruction pointer and execute it.
//    * Jump to `process_bytecode_with_loader_test`.
//
namespace bytecode {


// ASSUMES: in the channel process loop
// KEEP: x
inline func mark_vol_shadow_dirty__inline() {
    volShadowDirty_tmp $ 7 = true;
}


// Y = 0
// KEEP: X
func skip_last_loop_u16be(channelIndex : u8 in x, bytesToSkip_h : u8 in a) {
    >:zpTmpWord = a;

    // Y = 0;
    a = instructionPtr[y];
    instructionPtr++;

    return __skip_last_loop__bytesToSkip_l(x, a);
}


// Y = 0
// KEEP: X
#[fallthrough]
func skip_last_loop_u8(channelIndex : u8 in x, bytesToSkip_l : u8 in a) {
    // Zero high byte
    >:zpTmpWord = 0;

// Fallthrough into __skip_last_loop_()
}


// IN: A = low byte of skip-last-loop argument
// IN: >:zpTmpWord = high byte of skip-last-loop argument
// KEEP: X
func __skip_last_loop__bytesToSkip_l(channelIndex : u8 in x, bytesToSkip_l : u8 in a) {
    <:zpTmpWord = a;

    // `skip_last_loop` is here so I can `bne` to process_bytecode().
    return __skip_last_loop__inline(x, zpTmpWord);
}



// IN: Y = 0
// KEEP: X
#[fallthrough]
func set_vibrato_depth_and_play_note(channelIndex : u8 in x, pitchOffsetPerTick: u8 in a) {
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;

    // Read first byte of `_play_note`
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

// Fallthrough
}


// Y unknown
// KEEP: x
#[fallthrough]
func _play_note(channelIndex : u8 in x, noteAndKeyOffBit : u8 in a) {
    // carry = key-off after note ends bit
    a >>>= 1;

    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // calculate pitch table index
    y = a = a + channelSoA.instPitchOffset[x] + channelSoA.transpose[x];

    // Set voice pitch
    a = commonData.pitchTable_l[y] + channelSoA.detune_l[x];
    channelSoA.virtualChannels.pitch_l[x] = a;
    a = commonData.pitchTable_h[y] +# channelSoA.detune_h[x];

// Fallthough into __play_note_set_pitch_h();
}


// Y unknown
// KEEP: X
func __play_note_set_pitch_h(channelIndex: u8 in x, pitch_h: u8 in a) {
    channelSoA.virtualChannels.pitch_h[x] = a;

    // Get note length from the next byte in the instructionPtr
    y = 0;
    a = instructionPtr[y];
    instructionPtr++;

    channelSoA.countdownTimer[x] = a;

    // Y = 0
    // disable portamento
    channelSoA.portamento_direction[x] = y as i8;

    // Reset early release min-tick counter.
    // Y = 0
    a = y;
    channelSoA.ticksAfterNote[x] = a;

    // Restart vibrato (if active)
    // Y = 0
    channelSoA.vibrato_direction[x] = y;
    channelSoA.vibrato_tickCounter[x] = a = channelSoA.vibrato_tickCounterStart[x];


    // queue KON if the previous note has been KOFFed
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        // Disable noise
        test_and_clear(a, pendingNon_sfx);

        a &= keyOnMask_sfx;
        test_and_set(a, keyOnShadow_sfx);

        // Disable KON the next time the note is played (slur the note)
        test_and_clear(a, keyOnMask_sfx);

        return;
    }

    // Disable noise
    test_and_clear(a, pendingNon_music);

    a &= keyOnMask_music;
    test_and_set(a, keyOnShadow_music);

    // Disable KON the next time the note is played (slur the note)
    test_and_clear(a, keyOnMask_music);
}


// IN: Y = 0
// KEEP: X
func play_pitch(channelIndex: u8 in x, pitch_l : u8 in a) {
    // play_pitch does not detune the pitch.
    // Done to ensure VxPITCH is exactly what the song author wants and to avoid a save/restore carry.

    channelSoA.virtualChannels.pitch_l[x] = a;

    // Y = 0
    a = instructionPtr[y];  // pitch_h and key-off flag
    instructionPtr++;

    a >>>= 1;
    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    return __play_note_set_pitch_h(x, a);
}


// IN: Y = 0
// KEEP: X
func play_noise(channelIndex: u8 in x, freq_and_keyoff : u8 in a) {
    a >>>= 1;
    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    a &= dsp.FLG__NOISE_FREQ_MASK;
    push(a);

    // Wait length
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    channelSoA.countdownTimer[x] = a;

    // Reset early release min-tick counter.
    // Y = 0
    a = y;
    channelSoA.ticksAfterNote[x] = a;

    y = pop();

    // queue KON if the previous note has been KOFFed
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        a = ChannelVoiceBit[x];

        (&noiseFreq_sfx[-FIRST_SFX_CHANNEL])[x] = y;

        lastSfxPlayNoiseChannel = a;
        test_and_set(a, pendingNon_sfx);

        a &= keyOnMask_sfx;
        test_and_set(a, keyOnShadow_sfx);

        // Disable KON the next time the note is played (slur the note)
        test_and_clear(a, keyOnMask_sfx);

        return;
    }

    noiseFreq_music = y;

    test_and_set(a, pendingNon_music);


    a &= keyOnMask_music;
    test_and_set(a, keyOnShadow_music);

    // Disable KON the next time the note is played (slur the note)
    test_and_clear(a, keyOnMask_music);
}


// KEEP: X
func keyon_next_note(channelIndex : u8 in x) {
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        test_and_set(a, keyOnMask_sfx);
        ^return process_next_bytecode(x);
    }

    test_and_set(a, keyOnMask_music);
    ^return process_next_bytecode(x);
}


let portamento_up = __portamento_note as func(u8 in x, u8 in a);

// IN: Y = 0
// KEEP: X
#[fallthrough]
func portamento_down(channelIndex : u8 in x, noteAndKeyoffFlag : u8 in a) {
    y = -2 as u8;

// Fallthrough into __portamento_note()
}


// IN: Y = 0 or -2
// KEEP: X
#[fallthrough]
func __portamento_note(channelIndex : u8 in x, noteAndKeyoffFlag : u8 in a, direction_minus_one : u8 in y) {
    y++;
    // Y = 1 or -1
    channelSoA.portamento_direction[x] = y as i8;

    // carry = key-off after note ends bit
    a >>>= 1;
    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // calculate pitch table index
    y = a = a + channelSoA.instPitchOffset[x] + channelSoA.transpose[x];

    a = commonData.pitchTable_l[y] + channelSoA.detune_l[x];
    channelSoA.portamento_target_l[x] = a;
    a = commonData.pitchTable_h[y] +# channelSoA.detune_h[x];

    y = 0;

// fallthrough into __portamento_read_speed_length()
}


// Assumes portamento_direction and portamento_target_l set
//
// IN: Y = 0
// KEEP: X
func __portamento_read_speed_length(channelIndex : u8 in x, target_h : u8 in a) {
    channelSoA.portamento_target_h[x] = a;

    // Speed
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;
    channelSoA.portamento_speed[x] = a;

    // Wait length
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;
    channelSoA.countdownTimer[x] = a;


    // Reset early release min-tick counter.
    // Y = 0
    a = y;
    channelSoA.ticksAfterNote[x] = a;


    // return (do not execute the next bytecode and sleep)
    return;
}


let portamento_pitch_up = __portamento_pitch as func(u8 in x, u8 in a);

// IN: Y = 0
// KEEP: X
#[fallthrough]
func portamento_pitch_down(channelIndex : u8 in x, targetPitch_l : u8 in a) {
    y = -2 as u8;

// Fallthrough into __portamento_pitch()
}


// IN: Y = 0 or -2
// KEEP: X
func __portamento_pitch(channelIndex : u8 in x, targetPitch_l : u8 in a, direction_minus_one : u8 in y) {
    y++;
    // Y = 1 or -1
    channelSoA.portamento_direction[x] = y as i8;

    channelSoA.portamento_target_l[x] = a;

    // target_h and key-off flag
    y = 0;
    a = instructionPtr[y];
    instructionPtr++;

    a >>>= 1;
    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // a = target_h
    // y = 0 (required)

    return __portamento_read_speed_length(x, a);
}



// IN: Y = 0
// KEEP: X
func portamento_pitch_calc(channelIndex : u8 in x, targetPitch_l : u8 in a) {
    var _tmp : u16 in  zpTmpWord;

    channelSoA.portamento_target_l[x] = a;
    <:_tmp = a;

    // target_h and key-off flag
    a = instructionPtr[y];
    instructionPtr++;

    a >>>= 1;
    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // a = target_h
    ^return __portamento_calc_read_lengths(x, a);
}



// NOTE: Y is non-zero
// KEEP: X
#[fallthrough]
func portamento_calc(channelIndex : u8 in x, noteAndKeyoffFlag : u8 in a) {
    var _tmp : u16 in  zpTmpWord;

    // carry = key-off after note ends bit
    a >>>= 1;
    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // calculate pitch table index
    y = a = a + channelSoA.instPitchOffset[x] + channelSoA.transpose[x];

    a = commonData.pitchTable_l[y] + channelSoA.detune_l[x];
    channelSoA.portamento_target_l[x] = a;
    <:_tmp = a;

    a = commonData.pitchTable_h[y] +# channelSoA.detune_h[x];

// fallthrough into __portamento_calc_read_lengths()
}


// IN: <:_tmp = low byte of target
// Y is non-zero
// KEEP:X
func __portamento_calc_read_lengths(channelIndex: u8 in x, target_h: u8 in a) {
    var _tmp : u16 in  zpTmpWord;

    channelSoA.portamento_target_h[x] = a;
    >:_tmp = a;

    // length
    y = 0;
    a = instructionPtr[y];
    instructionPtr++;
    channelSoA.countdownTimer[x] = a;

    // Reset early release min-tick counter.
    // Y = 0
    a = y;
    channelSoA.ticksAfterNote[x] = a;


    // slide length in ticks
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    push(x);
    {
        push(a);
        {
            // Set down direction
            // Y = 0
            y--;
            channelSoA.portamento_direction[x] = y as i8;

            a = channelSoA.virtualChannels.pitch_l[x];
            y = channelSoA.virtualChannels.pitch_h[x];

            ya -= _tmp;
            if negative {
                // switch to up direction
                channelSoA.portamento_direction[x] >>>= 1;

                // negate ya
                _tmp = ya;
                y = a = 0;
                ya -= _tmp;
            }
        }
        x = pop();

        divmod(ya, x);
        if overflow {
            // ares states overflow set if quotient >= 256 (even if output is invalid)
            // ::TODO test an other emulators and real hardware::
            a = 0xff;
        }
        else {
            // Required for long portamentos and low octaves
            y = a;
            if zero {
                a++;
            }
        }
    }
    x = pop();

    channelSoA.portamento_speed[x] = a;

    // return (do not execute the next bytecode and sleep)
    return;
}



// IN: Y = 0
// KEEP: X
func set_vibrato(channelIndex : u8 in x, pitchOffsetPerTick: u8 in a) {
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;

    // Y = 0
    a = y;
    return _set_vibrato_delay_and_wavelength(x, a);
}



// IN: Y = 0
// KEEP: X
#[fallthrough]
func set_vibrato_with_delay(channelIndex : u8 in x, pitchOffsetPerTick: u8 in a) {
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;

    // Read vibrato-delay-in-ticks parameter
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

// Fallthrough into _set_vibrato_delay_and_wavelength()
}


// IN: Y = 0
// KEEP: X
#[fallthrough]
func _set_vibrato_delay_and_wavelength(channelIndex : u8 in x, vibratoDelay: u8 in a) {
    channelSoA.vibrato_delay[x] = a;

    // Read quarterWavelengthInTicks parameter
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    // Rest vibrato direction
    // Y = 0
    channelSoA.vibrato_direction[x] = y;

    channelSoA.vibrato_tickCounterStart[x] = a;
    channelSoA.vibrato_tickCounter[x] = a;

    a <<<= 1;
    channelSoA.vibrato_halfWavelength[x] = a;

    ^return process_next_bytecode(x);
}



// KEEP: X
func start_loop(channelIndex : u8 in x, loopCount : u8 in a) {
    var _loopCount : u8 in  zpTmp;

    _loopCount = a;

    a = channelSoA.stackPointer[x] - 3;
    goto disable_channel if a < BcStackIndexesEnd[x];

    channelSoA.stackPointer[x] = a;
    channelSoA.loopStackPointer[x] = a;

    y = a;
    (&bcStack[0])[y] = a = _loopCount;
    (&bcStack[1])[y] = a = <:instructionPtr;
    (&bcStack[2])[y] = a = >:instructionPtr;

    ^return process_next_bytecode(x);
}



// KEEP: X
inline func __skip_last_loop__inline(channelIndex : u8 in x, bytesToSkip : u16 in zpTmpWord) {
    // No need to bounds check `loopStackPointer`, it is always in bounds.
    y = channelSoA.loopStackPointer[x];

    a = (&bcStack[0])[y]; // loop counter
    a--;
    goto process_next_bytecode if !zero;

    // Assumes `y + 3` is a valid stackPointer
    channelSoA.stackPointer[x] = a = y + 3;
    if a < ValidLoopStackPointerTable[x] {
        // Only write to loopStackPointer if it is valid
        channelSoA.loopStackPointer[x] = a;
    }

    ya = zpTmpWord;
    ya += instructionPtr as u16;

    ^return process_bytecode_with_loader_test(x, ya);
}



// KEEP: X
func end_loop(channelIndex : u8 in x) {
    // No need to bounds check `loopStackPointer`, it is always in bounds.
    y = channelSoA.loopStackPointer[x];

    a = (&bcStack[0])[y]; // loop counter
    a--;
    if !zero {
        (&bcStack[0])[y] = a; // loop counter

        <:instructionPtr = a = (&bcStack[1])[y];
        >:instructionPtr = a = (&bcStack[2])[y];

        ^return process_next_bytecode(x);
    }

    // Assumes `y + 3` is a valid stackPointer
    channelSoA.stackPointer[x] = a = y + 3;
    if a < ValidLoopStackPointerTable[x] {
        // Only write to loopStackPointer if it is valid
        channelSoA.loopStackPointer[x] = a;
    }

    ^return process_next_bytecode(x);
}



// KEEP: X
func disable_channel(channelIndex : u8 in x) {
    // Y may not be 0

    // countdownTimer value of 0 means wait 256 ticks
    a = 0;
    channelSoA.countdownTimer[x] = a;

    // No bytecode is processed if instructionPtr_h is 0
    >:instructionPtr = a;

    // Disable portamento
    channelSoA.portamento_direction[x] = a as i8;

    // Disable vibrato
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;


    // Determine if this is a music or sound effect channel.
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        // X is a sound effect channel

        // Send key-off event
        test_and_set(a, keyOffShadow_sfx);

        // Disable echo
        test_and_clear(a, eonShadow_sfx);

        // Not disabling noise.
        // `pendingNon_sfx` will be cleared on the tick after Key-Off

        // Disable sfx S-DSP writes.
        test_and_clear(a, activeSoundEffects);

        // Clear `sfx_oneChannelSfxId` so the sfx can be restarted if it is not interruptible.
        (&sfx_oneChannelSfxId[-N_MUSIC_CHANNELS])[x] = a = 0xff;

        // return (do not execute the next bytecode and sleep)
        return;
    }


    // X is a music channel

    // Send key-off event
    test_and_set(a, keyOffShadow_music);

    // return (do not execute the next bytecode and sleep)
    return;
}



// Y = 0
// KEEP: X
func goto_relative(channelIndex : u8 in x, offset_l : u8 in a) {
    // Y = 0
    push(a);
    y = a = instructionPtr[y];
    a = pop();

    ya += instructionPtr as u16;
    ^return process_bytecode_with_loader_test(x, ya);
}



// IN: Y = 0
// KEEP: X
#[fallthrough]
func call_subroutine_and_disable_vibrato(channelIndex : u8 in x, subroutineId : u8 in a) {
    // Disable vibrato
    // Y = 0
    channelSoA.vibrato_pitchOffsetPerTick[x] = y;

// Fallthrough
}


// IN: Y = 0
// KEEP: X
func call_subroutine(channelIndex : u8 in x, subroutineId : u8 in a) {
var _subroutineId : u8 in zpTmp;

    _subroutineId = a;

    a = channelSoA.stackPointer[x];
    a--;
    a--;
    goto disable_channel if a < BcStackIndexesEnd[x];

    channelSoA.stackPointer[x] = a;

    y = a;
    (&bcStack[0])[y] = a = <:instructionPtr;
    (&bcStack[1])[y] = a = >:instructionPtr;

    // Add songPtr to subroutineTable[y] to get the subroutine address
    y = _subroutineId;

    if x < FIRST_SFX_CHANNEL {
        // carry clear
        <:instructionPtr = a = (subroutineTable_l as *u8)[y] +# <:songPtr;
        >:instructionPtr = a = (subroutineTable_h as *u8)[y] +# >:songPtr;

        ^return process_next_bytecode(x);
    }

    // SFX subroutine
    <:instructionPtr = a = commonData.sfxSubroutines_l[y];
    >:instructionPtr = a = commonData.sfxSubroutines_h[y];

    ^return process_next_bytecode(x);
}



// KEEP: X
#[fallthrough]
func return_from_subroutine_and_disable_vibrato(channelIndex : u8 in x) {
    // Disable vibrato
    channelSoA.vibrato_pitchOffsetPerTick[x] = a = 0;

// Fallthrough
}


// KEEP: X
func return_from_subroutine(channelIndex : u8 in x) {

    a = channelSoA.stackPointer[x];
    a++;
    goto disable_channel if a >= BcStackIndexesStart[x];
    a++;

    channelSoA.stackPointer[x] = a;

    if a < ValidLoopStackPointerTable[x] {
        // Only write to loopStackPointer if it is valid
        channelSoA.loopStackPointer[x] = a;
    }

    y = a;
    <:instructionPtr = a = (&bcStack[-2])[y];
    >:instructionPtr = a = (&bcStack[-1])[y];

    ^return process_next_bytecode(x);
}



// KEEP: X
func enable_echo(channelIndex : u8 in x) {
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        test_and_set(a, eonShadow_sfx);
        ^return process_next_bytecode(x);
    }

    test_and_set(a, eonShadow_music);
    ^return process_next_bytecode(x);
}



// KEEP: X
func disable_echo(channelIndex : u8 in x) {
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        test_and_clear(a, eonShadow_sfx);
        ^return process_next_bytecode(x);
    }

    test_and_clear(a, eonShadow_music);
    ^return process_next_bytecode(x);
}



// IN: Y = 0
// KEEP: X
func set_instrument(channelIndex : u8 in x, instrumentId : u8 in a) {
    // disable temp GAIN
    channelSoA.virtualChannels.tempGain[x] = y;

    y = a;

    channelSoA.instPitchOffset[x] = a = commonData.instruments_pitchOffset[y];

    channelSoA.virtualChannels.scrn[x] = a = commonData.instruments_scrn[y];
    channelSoA.virtualChannels.adsr1[x] = a = commonData.instruments_adsr1[y];
    channelSoA.virtualChannels.adsr2OrGain[x] = a = commonData.instruments_adsr2OrGain[y];

    ^return process_next_bytecode(x);
}



// IN: Y = 0
// KEEP: X
func set_instrument_and_adsr_or_gain(channelIndex : u8 in x, instrumentId : u8 in a) {
    // disable temp GAIN
    channelSoA.virtualChannels.tempGain[x] = y;

    y = a;

    channelSoA.instPitchOffset[x] = a = commonData.instruments_pitchOffset[y];

    channelSoA.virtualChannels.scrn[x] = a = commonData.instruments_scrn[y];

    // Read ADSR/GAIN from `instructionPtr`.
    y = 0;
    channelSoA.virtualChannels.adsr1[x] = a = instructionPtr[y];
    instructionPtr++;

    channelSoA.virtualChannels.adsr2OrGain[x] = a = instructionPtr[y];
    instructionPtr++;

    ^return process_next_bytecode(x);
}



// IN: Y = 0
// KEEP: X
func set_adsr(channelIndex: u8 in x, adsr1 : u8 in a) {
    // disable temp GAIN
    channelSoA.virtualChannels.tempGain[x] = y;

    channelSoA.virtualChannels.adsr1[x] = a;

    // Y = 0
    channelSoA.virtualChannels.adsr2OrGain[x] = a = instructionPtr[y];
    instructionPtr++;

    ^return process_next_bytecode(x);
}



// IN: Y = 0
// KEEP: X
func set_gain(channelIndex: u8 in x, gain : u8 in a) {
    // disable temp GAIN
    channelSoA.virtualChannels.tempGain[x] = y;

    // Y = 0
    channelSoA.virtualChannels.adsr1[x] = y;

    channelSoA.virtualChannels.adsr2OrGain[x] = a;

    ^return process_next_bytecode(x);
}



// Y = 0
// KEEP: X
func set_early_release_no_minimum(channelIndex: u8 in x, cmp_: u8 in a) {
    channelSoA.earlyRelease_cmp[x] = a;

    // Y = 0
    a = y;
    channelSoA.earlyRelease_minTicks[x] = a;

    return __set_early_release_gain(x);
}


// Y = 0
// KEEP: X
#[fallthrough]
func set_early_release(channelIndex: u8 in x, cmp_: u8 in a) {
    channelSoA.earlyRelease_cmp[x] = a;

    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;
    channelSoA.earlyRelease_minTicks[x] = a;

// Fallthrough into __set_early_release_gain(x);
}


// Y = 0
// KEEP: X
func __set_early_release_gain(channelIndex: u8 in x) {
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    channelSoA.earlyRelease_gain[x] = a;

    ^return process_next_bytecode(x);
}


// Y = 0
// KEEP: X
#[fallthrough]
func adjust_transpose(channelIndex: u8 in x, transpose : i8 in a) {
    a += channelSoA.transpose[x];

// fallthrough into `set_transpose`
}


// Y = 0
// KEEP: X
func set_transpose(channelIndex: u8 in x, transpose : i8 in a) {
    channelSoA.transpose[x] = a;

    ^return process_next_bytecode(x);
}


// Y = 0
// KEEP: X
func set_detune_i16(channelIndex: u8 in x, detune_l : u8 in a) {
    channelSoA.detune_l[x] = a;

    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    channelSoA.detune_h[x] = a;

    ^return process_next_bytecode(x);
}


// KEEP: X
#[fallthrough]
func set_detune_n8(channelIndex: u8 in x, detune_l : u8 in a) {
    y = 0xff;

// Fallthrough in _set_detune()
}

// Y = 0 or 0xff
// KEEP: X
func _set_detune_8(channelIndex: u8 in x, detune_l : u8 in a, detune_h : u8 in y) {
    channelSoA.detune_l[x] = a;

    channelSoA.detune_h[x] = a = y;

    ^return process_next_bytecode(x);
}


// Y = 0
// KEEP: X
let set_detune_p8 = _set_detune_8 as func(u8 in x, u8 in a);


// KEEP: X
#[fallthrough]
func adjust_pan(channelIndex : u8 in x, detla : i8 in a) {
    carry = false;

    y = a;
    if negative {
        // carry clear, A is negative
        a +#= channelSoA.pan[x];
        if !carry {
            a = 0;
        }
    }
    else {
        // carry clear, A is positive
        a += channelSoA.pan[x];
        if carry || a >= MAX_PAN + 1 {
            a = MAX_PAN;
        }
    }

// Fallthrough
}



// KEEP: X
func set_pan(channelIndex : u8 in x, pan : u8 in a) {
    channelSoA.pan[x] = a;

    // Disable pan effects
    // (Y is non-zero)
    channelSoA.panEffect_direction[x] = a = 0;

    mark_vol_shadow_dirty__inline();

    ^return process_next_bytecode(x);
}



// REQUIRES: Y = 0
// KEEP: X
func set_pan_and_volume(channelIndex : u8 in x, pan : u8 in a) {
    // Y is 0

    channelSoA.pan[x] = a;

    // Disable pan effects
    // Y = 0
    channelSoA.panEffect_direction[x] = a = y;

    a = instructionPtr[y];
    instructionPtr++;

    return set_volume(x, a);
}



// KEEP:X
#[fallthrough]
func adjust_volume(channelIndex : u8 in x, delta: i8 in a) {
    carry = false;

    y = a;
    if negative {
        // carry clear, A is negative
        a +#= channelSoA.volume[x];
        if !carry {
            a = 0;
        }
    }
    else {
        // carry clear, A is positive
        a +#= channelSoA.volume[x];
        if carry {
            a = 0xff;
        }
    }

// Fallthrough
}


// KEEP: X
func set_volume(channelIndex : u8 in x, volume : u8 in a) {
    channelSoA.volume[x] = a;

    mark_vol_shadow_dirty__inline();

    // Disable volume effects
    // (Y is non-zero)
    channelSoA.volEffect_direction[x] = a = 0;

    ^return process_next_bytecode(x);
}


// KEEP: X
func set_channel_or_echo_invert(channelIndex : u8 in x, flags : u8 in a) {
    // If not in surround mode, set all flags to the mono-flag
    //
    // (cannot use `bbs` instructions in wiz, using `mov1 c, addr, bit` instead)
    carry = loaderDataType $ LoaderDataType.SURROUND_FLAG_BIT;
    if !carry {
        // Have to push and pop MSB using carry, the spc700 has no `bit` instruction.
        a <<<= 1;

        a &= INVERT_FLAGS.MONO;
        if !zero {
            a = 0xff;
        }

        a >>>>#= 1;
    }

    // Have to bit-shift parameter, the spc700 has no `bit` instruction.
    a <<<= 1;
    if carry {
        // set channel invert
        channelSoA.invertFlags[x] = a;

        mark_vol_shadow_dirty__inline();

        ^return process_next_bytecode(x);
    }
    // else

    // set echo invert

    echo.invertFlags = a;

    echoDirty $ ECHO_DIRTY__VOLUME_BIT = true;

    ^return process_next_bytecode(x);
}


// Y = 0
// KEEP: x
func volume_slide_up(channelIndex: u8 in x, ticks: u8 in a) {
    var _csv_counter        @ &channelSoA.volEffect_counter         as u8 : [u8 ; N_CHANNELS];

    direct_page = true;

    _csv_counter[x] = a;

    // Y (sub_volume) = 0
    return __volume_slide__dp_true__(x, VOL_PAN_EFFECT_SLIDE_UP, y);
}


// Y = 0
// KEEP: x
#[fallthrough]
func volume_slide_down(channelIndex: u8 in x, ticks: u8 in a) {
    var _csv_counter        @ &channelSoA.volEffect_counter         as u8 : [u8 ; N_CHANNELS];

    direct_page = true;

    _csv_counter[x] = a;

    a = VOL_PAN_EFFECT_SLIDE_DOWN;

    y--;
    // Y (sub_volume) = 0xff

// Fallthrough into __volume_slide__dp_true__()
}


// Y = 0
// direct_page = true
// KEEP: x
#[fallthrough]
func __volume_slide__dp_true__(channelIndex: u8 in x, direction: u8 in a, subVolume: u8 in y) {
    var _csv_direction      @ &channelSoA.volEffect_direction       as u8 : [u8 ; N_CHANNELS];
    var _csv_halfWavelength @ &channelSoA.volEffect_halfWavelength  as u8 : [u8 ; N_CHANNELS];

    _csv_direction[x] = a;

    // halfWavelength
    a = 0;

// Fallthrough into __read_vol_effect_offset__dp_true__()
}


// Y = 0
// direct_page = true
// KEEP: x
// OUT: direct_page = false
func __read_vol_effect_offset__dp_true__(channelIndex: u8 in x, halfWavelength: u8 in a, subVolume: u8 in y) {
    var _csv_halfWavelength @ &channelSoA.volEffect_halfWavelength  as u8 : [u8 ; N_CHANNELS];
    var _csv_subVolume      @ &channelSoA.subVolume                 as u8 : [u8 ; N_CHANNELS];

    _csv_halfWavelength[x] = a;
    _csv_subVolume[x] = y;

    direct_page = false;

    y = 0;
    channelSoA.volEffect_offset_l[x] = a = instructionPtr[y];
    instructionPtr++;
    channelSoA.volEffect_offset_h[x] = a = instructionPtr[y];
    instructionPtr++;

    ^return process_next_bytecode(x);
}


// Y = 0
// KEEP: X
func tremolo(channelIndex: u8 in x, quarter_wavelength: u8 in a) {
    var _csv_counter        @ &channelSoA.volEffect_counter         as u8 : [u8 ; N_CHANNELS];
    var _csv_direction      @ &channelSoA.volEffect_direction       as u8 : [u8 ; N_CHANNELS];

    direct_page = true;

    _csv_direction[x] = y = VOL_PAN_EFFECT_TRIANGLE_UP;

    _csv_counter[x] = a;

    // halfWavelength
    a = a << 1;

    // subVolume
    y = 0x7f;
    return __read_vol_effect_offset__dp_true__(x, a, y);
}


// Y = 0
// KEEP: x
func pan_slide_up(channelIndex: u8 in x, ticks: u8 in a) {
    var _csp_counter        @ &channelSoA.panEffect_counter         as u8 : [u8 ; N_CHANNELS];

    direct_page = true;

    _csp_counter[x] = a;

    // Y (subPan) = 0
    return __pan_slide__dp_true__(x, VOL_PAN_EFFECT_SLIDE_UP, y);
}


// Y = 0
// KEEP: x
#[fallthrough]
func pan_slide_down(channelIndex: u8 in x, ticks: u8 in a) {
    var _csp_counter        @ &channelSoA.panEffect_counter         as u8 : [u8 ; N_CHANNELS];

    direct_page = true;

    _csp_counter[x] = a;

    a = VOL_PAN_EFFECT_SLIDE_DOWN;

    y--;
    // Y (subPan) = 0xff

// Fallthrough into __pan_slide__dp_true__()
}


// Y = 0
// direct_page = true
// KEEP: x
#[fallthrough]
func __pan_slide__dp_true__(channelIndex: u8 in x, direction: u8 in a, subPan: u8 in y) {
    var _csp_direction      @ &channelSoA.panEffect_direction       as u8 : [u8 ; N_CHANNELS];
    var _csp_halfWavelength @ &channelSoA.panEffect_halfWavelength  as u8 : [u8 ; N_CHANNELS];

    _csp_direction[x] = a;

    // halfWavelength
    a = 0;

// Fallthrough into __read_pan_effect_offset__dp_true__()
}


// Y = 0
// direct_page = true
// KEEP: x
// OUT: direct_page = false
func __read_pan_effect_offset__dp_true__(channelIndex: u8 in x, halfWavelength: u8 in a, subPan: u8 in y) {
    var _csp_halfWavelength @ &channelSoA.panEffect_halfWavelength  as u8 : [u8 ; N_CHANNELS];
    var _csp_subPan         @ &channelSoA.subPan                    as u8 : [u8 ; N_CHANNELS];

    _csp_halfWavelength[x] = a;
    _csp_subPan[x] = y;

    direct_page = false;

    y = 0;
    channelSoA.panEffect_offset_l[x] = a = instructionPtr[y];
    instructionPtr++;
    channelSoA.panEffect_offset_h[x] = a = instructionPtr[y];
    instructionPtr++;

    ^return process_next_bytecode(x);
}


// Y = 0
// KEEP: X
func panbrello(channelIndex: u8 in x, quarter_wavelength: u8 in a) {
    var _csp_counter        @ &channelSoA.panEffect_counter         as u8 : [u8 ; N_CHANNELS];
    var _csp_direction      @ &channelSoA.panEffect_direction       as u8 : [u8 ; N_CHANNELS];

    direct_page = true;

    _csp_direction[x] = y = VOL_PAN_EFFECT_TRIANGLE_UP;

    _csp_counter[x] = a;

    // halfWavelength
    a = a << 1;

    // subPan
    y = 0x7f;
    return __read_pan_effect_offset__dp_true__(x, a, y);
}



// KEEP: x
func reuse_temp_gain(channelIndex : u8 in x) {
    a = channelSoA.prevTempGain[x];
    channelSoA.virtualChannels.tempGain[x] = a;

    ^return process_next_bytecode(x);
}


// KEEP: x
func reuse_temp_gain_and_wait(channelIndex : u8 in x, ticks : u8 in a) {
    y = a;

    a = channelSoA.prevTempGain[x];
    channelSoA.virtualChannels.tempGain[x] = a;

    a = y;
    return wait(x, a);
}


// KEEP: x
func reuse_temp_gain_and_rest(channelIndex : u8 in x, ticks : u8 in a) {
    y = a;

    a = channelSoA.prevTempGain[x];
    channelSoA.virtualChannels.tempGain[x] = a;

    a = y;
    return rest(x, a);
}


// KEEP: x
func set_temp_gain(channelIndex : u8 in x, tempGain: u8 in a) {
    channelSoA.virtualChannels.tempGain[x] = a;
    channelSoA.prevTempGain[x] = a;

    ^return process_next_bytecode(x);
}


// IN: Y = 0
// KEEP: x
func set_temp_gain_and_wait(channelIndex : u8 in x, tempGain: u8 in a) {
    channelSoA.virtualChannels.tempGain[x] = a;
    channelSoA.prevTempGain[x] = a;

    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    return wait(x, a);
}


// IN: Y = 0
// KEEP: x
#[fallthrough]
func set_temp_gain_and_rest(channelIndex : u8 in x, tempGain: u8 in a) {
    channelSoA.virtualChannels.tempGain[x] = a;
    channelSoA.prevTempGain[x] = a;

    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

// Fallthrough into rest()
}


// KEEP: x
#[fallthrough]
func rest(channelIndex : u8 in x, length: u8 in a) {
    // Y is not 0

    channelSoA.nextEventIsKeyOff[x] = y = 1;
// Fallthrough
}


// KEEP: x
func wait(channelIndex : u8 in x, length: u8 in a) {
    // Y is not 0

    channelSoA.countdownTimer[x] = a;

    // return (do not execute the next bytecode and sleep)
    return;
}


// KEEP: x
func set_echo_volume(channelIndex : u8 in x, volume: u8 in a) {
    a &= 0x7f;
    echo.echoVolume_l = a;

    return __set_stereo_echo_volume_r(x, a);
}


// IN: Y
// KEEP: x
#[fallthrough]
func set_stereo_echo_volume(channelIndex : u8 in x, left: u8 in a) {
    a &= 0x7f;
    echo.echoVolume_l = a;

    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    a &= 0x7f;
// Fallthrough into __set_stereo_echo_volume_r
}


// CAUTION: right is unchecked
// KEEP: x
func __set_stereo_echo_volume_r(channelIndex : u8 in x, right: u8 in a) {
    echo.echoVolume_r = a;

    echoDirty $ ECHO_DIRTY__VOLUME_BIT = true;

    ^return process_next_bytecode(x);
}


// KEEP: x
func adjust_echo_volume(channelIndex : u8 in x, adjust: i8 in a) {
    push(a);

    // Y = 0
    __adjust_echo_volume_channel(a as i8, y);

    a = pop();
    return __adjust_stereo_echo_volume_r(x, a as i8);
}


// IN: Y = 0
// KEEP: X
#[fallthrough]
func adjust_stereo_echo_volume(channelIndex : u8 in x, left_adjust: i8 in a) {
    __adjust_echo_volume_channel(a as i8, y);

    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

// Fallthrough into __adjust_stereo_echo_volume_r(x, a)
}


// IN: Y = 0
// KEEP: X
func __adjust_stereo_echo_volume_r(channelIndex : u8 in x, right_adjust: i8 in a) {
    y++;
    __adjust_echo_volume_channel(a as i8, y);

    echoDirty $ ECHO_DIRTY__VOLUME_BIT = true;

    ^return process_next_bytecode(x);
}


// KEEP: Y
// KEEP: X
func __adjust_echo_volume_channel(adjust: i8 in a, evolChannel: u8 in y) {
    var _evol @ &echo.echoVolume_l as u8 : [u8 ; 2];

    // Assumes _evol[y] is <= 127
    a += _evol[y];
    if negative {
        a = 0;
        if overflow {
            a = 127;
        }
    }
    _evol[y] = a;
}


// IN: Y = 0
// KEEP: X
func set_fir_filter(channelIndex: u8 in x, fir0 : i8 in a) {
    echo.firFilter[0] = a as i8;

    y = 6;
    do {
        a = instructionPtr[y];
        (&echo.firFilter[1] as *i8)[y] = a as i8;
        y--;
    } while !negative;

    y++;
    a = 7;
    // Y = 0
    ya += instructionPtr as u16;

    echoDirty |= (1 << ECHO_DIRTY__FIR_FILTER_BIT) | (1 << ECHO_DIRTY__CLEAR_FIR_BIT);

    ^return process_bytecode(x, ya);
}


// IN: Y = 0
// KEEP: X
#[fallthrough]
func __set_or_adjust_echo_i8__out_of_bounds(channelIndex: u8 in x) {
    a = MAX_SET_OR_ADJUST_ECHO_I8_PARAM;

// Fallthrough into set_or_adjust_echo_i8(x, a)
}

// IN: Y = 0
// KEEP: X
func set_or_adjust_echo_i8(channelIndex: u8 in x, eIndexAndSetFlag : u8 in a) {
    goto __set_or_adjust_echo_i8__out_of_bounds if a >= MAX_SET_OR_ADJUST_ECHO_I8_PARAM + 1;

    push(x);
    x = a = a >>> 1;

    // carry = LSB of eIndexAndSetFlag

    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    if !carry {
        // Adjust echo i8

        a +#= echo.firFilter[x] as u8;
        if overflow {
            a = I8_MIN as u8;
            if !carry {
                a = I8_MAX as u8;
            }
        }
    }

    // assumes echo echoFeedback directly after firFilter
    echo.firFilter[x] = a as i8;

    if x < ECHO_I8_EFB_INDEX {
        echoDirty $ ECHO_DIRTY__FIR_FILTER_BIT = true;

        x = pop();
        ^return process_next_bytecode(x);
    }
    // else

    echoDirty $ ECHO_DIRTY__FEEDBACK_BIT = true;

    x = pop();
    ^return process_next_bytecode(x);
}


// IN: Y = 0
// KEEP: X
#[fallthrough]
func __adjust_echo_i8_limit__out_of_bounds(channelIndex: u8 in x) {
    a = ECHO_I8_EFB_INDEX;

// Fallthrough into adjust_echo_i8(x, a)
}

// IN: Y = 0
// KEEP: X
#[fallthrough]
func adjust_echo_i8_limit(channelIndex: u8 in x, echo_index : i8 in a) {
    goto __adjust_echo_i8_limit__out_of_bounds if a >= ECHO_I8_EFB_INDEX + 1;

    push(x);
    x = a;

    //   if adjust < 0 {
    //      firFilter[x] = firFilter[x].saturating_add(adjust).max(limit);
    //   } else {
    //      firFilter[x] = firFilter[x].saturating_add(adjust).min(limit);
    //   };

    // Y = 0
    a = instructionPtr[y];  // adjust
    goto PositiveAdjust if !negative;
        // A is negative
        instructionPtr++;

        a += echo.firFilter[x] as u8;
        goto WriteLimit if overflow;

        echo.firFilter[x] = a as i8;

        carry = true;
        a -#= instructionPtr[y]; // limit
        goto LimitNegativeTest if !overflow;
            a ^= 0xff;
        goto LimitNegativeTest;

    PositiveAdjust:
        // A is positive
        instructionPtr++;

        a += echo.firFilter[x] as u8;
        goto WriteLimit if overflow;

        echo.firFilter[x] = a as i8;

        // using clc for a > comparison
        // (SOURCE: http://6502.org/tutorials/compare_beyond.html#5.1)
        //
        // Using `bvs` to invert the negative flag and use the same negative branch instruction
        // for both positive and negative adjust code paths.
        carry = false;
        a -#= instructionPtr[y]; // limit
        goto LimitNegativeTest if overflow;
            a ^= 0xff;
    LimitNegativeTest:
        goto End if !negative;

        WriteLimit:
            a = instructionPtr[y]; // limit
            echo.firFilter[x] = a as i8;
    End:

    instructionPtr++;


    if x < ECHO_I8_EFB_INDEX {
        echoDirty $ ECHO_DIRTY__FIR_FILTER_BIT = true;

        x = pop();
        ^return process_next_bytecode(x);
    }
    // else

    echoDirty $ ECHO_DIRTY__FEEDBACK_BIT = true;

    x = pop();
    ^return process_next_bytecode(x);
}


let miscellaneous = misc_instructions.instruction;


namespace misc_instructions {

// KEEP: X
func instruction(channelIndex : u8 in x, argument: u8 in a) {
    a >>>= 1;
    if carry {
        a >>>= 1;

        // Y = 0
        a = instructionPtr[y];
        instructionPtr++;

        if !carry {
            _set_song_tick_clock__inline(x, a);
            ^return process_next_bytecode(x);
        }

        _set_echo_delay__inline(x, a);
        ^return process_next_bytecode(x);
    }

    if zero {
        _disable_noise__inline(x);
        ^return process_next_bytecode(x);
    }

    a >>>= 1;

    _enable_or_disable_pmod__inline(x, carry);
    ^return process_next_bytecode(x);
}


// KEEP: X
inline func _set_echo_delay__inline(channelIndex : u8 in x, edl: u8 in a) {
    if a > maxEdl {
        a = maxEdl;
    }
    echo.edl = a;

    echoDirty $ ECHO_DIRTY__EDL_BIT = true;
}


// Sets the timer for the music channels
//
// KEEP: X
inline func _set_song_tick_clock__inline(channelIndex : u8 in x, timer_clock: u8 in a) {
    // if (a > 0 && a < MIN_TICK_CLOCK) a = MIN_TICK_CLOCK
    a--;
    if a < MIN_TICK_CLOCK - 1 {
        a = MIN_TICK_CLOCK - 1;
    }
    a++;

    smp.timer_0 = a;
}


// KEEP: X
inline func _enable_or_disable_pmod__inline(channelIndex : u8 in x, enable: bool in carry) {
    a = ChannelVoiceBit[x] & ENABLE_PMOD_MASK;

    test_and_clear(a, pmonShadow);

    if carry {
        test_and_set(a, pmonShadow);
    }
}


// KEEP: X
inline func _disable_noise__inline(channelIndex: u8 in x) {
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        test_and_clear(a, pendingNon_sfx);

        ^return process_next_bytecode(x);
    }

    test_and_clear(a, pendingNon_music);

    ^return process_next_bytecode(x);
}

}


let reserved_for_custom_use = disable_channel as func(u8 in x, u8 in a);


const InstructionTable : [u16 ; 64] = [ f as u16 for let f in INSTRUCTIONS_WITH_ARGUMENTS ]
                                    ~ [ f as u16 for let f in NO_ARGUMENT_INSTRUCTIONS ];
}

}



// Data Tables
// ===========

// Using the `code` bank so the data is included in `audio-driver.bin`
in code {
    // The S-DSP voice used by each channel
    let __VOICE_CHANNELS = [0, 1, 2, 3, 4, 5, 6, 7, 6, 7];

    // The bit used for global DSP registers (KON, KOFF, NON, EON, etc)
    const ChannelVoiceBit : [u8; N_CHANNELS] = [1 << i for let i in __VOICE_CHANNELS];

    // The address of the last writeable voice DSP register for each channel
    const LastVoiceRegister : [u8; N_CHANNELS] = [i * 0x10 | 0x07 for let i in __VOICE_CHANNELS];


    let __BC_STACK_INDEXES = [ i * BC_CHANNEL_STACK_SIZE + BC_CHANNEL_STACK_OFFSET for let i in 0..N_CHANNELS];

    const _BcStackIndexes : [u8; N_CHANNELS + 1] = __BC_STACK_INDEXES;
        let BcStackIndexesStart = &_BcStackIndexes[1] as *u8;
        let BcStackIndexesEnd = &_BcStackIndexes[0] as *u8;

    // Used to determine if `loopStackPointer` is valid.
    // Equal to `BcStackIndexesEnd[x] - 3 + 1` (+1 for < comparison)
    const ValidLoopStackPointerTable : [u8; N_CHANNELS] = [ __BC_STACK_INDEXES[i + 1] - 3 + 1 for let i in 0..(N_CHANNELS - 1)];
}

import "bytecode";

